<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>a house in the woods</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="a house in the woods">
<meta property="og:url" content="https://sociosarbis.github.io/study-memo/index.html">
<meta property="og:site_name" content="a house in the woods">
<meta property="og:locale" content="zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="a house in the woods">
  
    <link rel="alternate" href="/study-memo/atom.xml" title="a house in the woods" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/study-memo/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/study-memo/" id="logo">a house in the woods</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/study-memo/">Home</a>
        
          <a class="main-nav-link" href="/study-memo/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/study-memo/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://sociosarbis.github.io/study-memo"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-misunderstandings-of-nginx-location-config" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2020/08/16/misunderstandings-of-nginx-location-config/" class="article-date">
  <time datetime="2020-08-16T06:12:08.966Z" itemprop="datePublished">2020-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2020/08/16/misunderstandings-of-nginx-location-config/">nginx location指令配置的误解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h3><p>可能因为nginx轻量，功能齐全，跨平台，高性能（由C编写）的原因，在不同语言编写的web应用中，都能看到它的身影。</p>
<p>最近因为想用docker配置php服务器，最后的目标是放在线下的服务器中，为测试人员提供多个测试环境。</p>
<p>在这个过程中，由于我对nginx的location指令的理解有误，导致在转发资源的路由配置上卡了许久。</p>
<p>后面经过经过自己的调试和重读nginx的手册，终于弄明白了。</p>
<h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><ol>
<li><code>location指令</code>是类似<code>express（node.js）</code>的中间件， 请求会在各个匹配的location中进行传递。</li>
</ol>
<p>产生这个误解是因为看到这个配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里只看到添加Expires的响应头，没看到返回响应主体的指令</span></span><br><span class="line">location ~ .*\.(js|css|mp4)?$ &#123;</span><br><span class="line">  expires 1h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为上面指令的存在，导致后面的这个指令一直未能匹配到</span></span><br><span class="line">location ~ ^/resource/(.*) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!-f <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">    rewrite ^/(.*?)/(.*?)/(.*?)/(.*)$ /code/mapi/<span class="variable">$2</span>/<span class="variable">$3</span>/<span class="variable">$1</span>/<span class="variable">$4</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正解</strong>：对于每个请求，所有的处理都只会在一个location指令内完成所有的处理，上面第一条指令没有显式设置返回主体是因为默认是返回请求路径的静态文件。这一点类似<code>webpack</code>的<code>output</code>设置<code>public path</code>和<code>path</code>，默认是一个静态资源的转发服务器。</p>
<ol>
<li><code>location指令</code>匹配的优先顺序，主要是看规则的匹配字符串的长度。不管规则是不是正则表达式，都会当成正则表达式处理（类似<code>javascript</code>的<code>String.prototype.replace</code>的第一个参数可以是字符串）。</li>
</ol>
<p>但如果按照上述的逻辑看的，感觉有点与事实相悖，因为<code>^/resource/(.*)</code>和<code>.*\.(js|css|mp4)?$</code>，如果请求是<code>/resource/teacher/3.0/areaSwitch.js</code>，理论上两个规则都能匹配全部字符，那这时是按照怎样的规则呢？</p>
<p>在某个博客的文章中找到了如下的文字说明：</p>
<p><img src="/study-memo/assets/images/nginx-location-priority.jpg" alt="nginx location配置优先级"></p>
<p>说是优先用正则表达式最长的那个。那把<code>^/resource/(.*)</code>改成<code>/resource/teacher/3.0/(.*)</code>是不是就可以了呢？发现也是不行。</p>
<p>最后只能在权威的资料（官方手册）中找答案了。</p>
<p>匹配逻辑只有简单的一段：</p>
<blockquote>
<p>A location can either be defined by a prefix string, or by a regular expression. Regular expressions are specified with the preceding “~*” modifier (for case-insensitive matching), or the “~” modifier (for case-sensitive matching). <strong>To find location matching a given request, nginx first checks locations defined using the prefix strings (prefix locations). Among them, the location with the longest matching prefix is selected and remembered. Then regular expressions are checked, in the order of their appearance in the configuration file. The search of regular expressions terminates on the first match, and the corresponding configuration is used. If no match with a regular expression is found then the configuration of the prefix location remembered earlier is used.</strong></p>
</blockquote>
<p>最重要的是加粗的那段，翻译过来整个流程是：</p>
<ol>
<li>首先遍历各个前缀匹配规则（所谓的前缀匹配，简单来说就是<strong>开头字符串匹配</strong>， 如<code>/resource/teacher</code>）， 然后记下匹配到的最长的前缀。</li>
<li>然后进入到正则匹配阶段（遍历各个正则表达式的规则），只要发现有一个匹配则会停止遍历。</li>
<li>假如第2步找不到匹配，则应用第1步记下的那个最长的规则。</li>
<li>整个流程有两个特例，分别是规则中的<code>=</code>和<code>^~</code>两个修饰符。<code>^~</code>表示假如当前规则是最长前缀，则跳过正则匹配阶段，直接应用当前规则；<code>=</code>则表示请求路径与规则字符相同，就直接应用当前规则。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>之前我一直被location的修饰符吸引注意力，而没留意整个匹配过程的细节，现在已豁然开朗。另外一点是查资料最好还是通过英文材料。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2020/08/16/misunderstandings-of-nginx-location-config/" data-id="ckdwr8ent0000dsu1o438pfh1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/location指令/">location指令</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-optimization-techniques-for-better-performance-of-vue-app" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2020/04/19/optimization-techniques-for-better-performance-of-vue-app/" class="article-date">
  <time datetime="2020-04-19T13:38:12.620Z" itemprop="datePublished">2020-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2020/04/19/optimization-techniques-for-better-performance-of-vue-app/">Vue应用性能调优技巧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这星期发现开发的某个页面的复选框的点击反馈比较的慢，为了给用户提供更好交互体验的信念，同时也为了验证积累的Vue框架的知识，决定改善这个部分的代码写法。而这个页面最开始是其他同事开发的，可能团队中一直都没有意识到这个问题，所以趁此机会分享这次调优的过程。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>原案例我把它稍简化以后放到codepen进行展示。</p>
<p></p><p class="codepen" data-height="265" data-theme-id="light" data-default-tab="js,result" data-user="sociosarbis" data-slug-hash="ExVyppE" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="speed up the interaction of a view with many checkboxes"><br>  <span>See the Pen <a href="https://codepen.io/sociosarbis/pen/ExVyppE" target="_blank" rel="noopener"><br>  speed up the interaction of a view with many checkboxes</a> by Sociosarbis (<a href="https://codepen.io/sociosarbis" target="_blank" rel="noopener">@sociosarbis</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p><strong>经过一些实验以后，有以下的发现</strong></p>
<ul>
<li>性能的瓶颈其实大部分都来自于DOM操作和渲染</li>
<li>依据视图依赖的数据，拆分独立组件，可以减少diff次数（这点其实之前已经有了解）</li>
</ul>
<p><strong>这次调优技巧涉及到3点</strong></p>
<ol>
<li>把复选框的每个组做成一个独立的组件。</li>
</ol>
<p>vue更新的大致机制是：</p>
<ol>
<li>在运行时或者编译时最终都会把template，转换成组件的render函数</li>
<li>执行render函数时返回虚拟DOM，在这过程中会收集render函数中的数据依赖（收集原理可参考<a href="https://sociosarbis.github.io/study-memo/2018/11/11/simple-implementation-of-observer-to-illustrate-how-vue-watcher-works/">通过简化版的Observer的实现来说明vue的watch的工作原理</a>), 当依赖数据改变时，再次执行render函数得到新的虚拟DOM，与旧虚拟DOM进行diff更新。</li>
<li>假如render函数中出现的自定义组件的props不发生改变，是不会去执行自定义组件的render函数，意思是不会diff更深一层，这样就能减少diff的次数。</li>
</ol>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">`&lt;el-tabs v-model="activeTab"&gt;</span></span><br><span class="line"><span class="string">  &lt;el-tab-pane class="tab__pane" v-for="tab in tabs" :key="tab.name" :name="tab.name" :label="tab.name + '(' + tabCount(tab) +')'"&gt;</span></span><br><span class="line"><span class="string">    `</span> + <span class="comment">/*&lt;div v-for="group in tab.groups" :key="group.name"&gt;</span></span><br><span class="line"><span class="comment">    &lt;div&gt;&lt;el-checkbox :value="group.selectedMembers.length === group.members.length" @input="group.selectedMembers = $event ? group.members : []" @click.native="startInteraction"/&gt;&#123;&#123;group.name + '(' + group.selectedMembers.length + ')'&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">      &lt;el-checkbox-group v-model="group.selectedMembers" @click.native="startInteraction"&gt;</span></span><br><span class="line"><span class="comment">        &lt;el-checkbox v-for="(member, index) in group.members" :label="member" :key="index" /&gt;</span></span><br><span class="line"><span class="comment">      &lt;/el-checkbox-group&gt;</span></span><br><span class="line"><span class="comment">    &lt;/div&gt; */</span> + <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;/el-tab-pane&gt;</span></span><br><span class="line"><span class="string">&lt;/el-tabs&gt;`</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>把注释掉的部分抽出改成<code>select-group</code>组件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">"select-group"</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&lt;div&gt;&lt;el-checkbox :value="group.selectedMembers.length === group.members.length" @input="group.selectedMembers = $event ? group.members : []" @click.native="$emit('click')"/&gt;&#123;&#123;group.name + '(' + group.selectedMembers.length + ')'&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;el-checkbox-group v-model="group.selectedMembers" @click.native="$emit('click')"&gt;</span></span><br><span class="line"><span class="string">        &lt;el-checkbox v-for="(member, index) in group.members" :label="member" :key="index" /&gt;</span></span><br><span class="line"><span class="string">      &lt;/el-checkbox-group&gt;&lt;/div&gt;`</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    group: <span class="built_in">Object</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>取消复选框的过渡动画</li>
</ol>
<ul>
<li>取消动画的原因是在全选/取消全选的时候，大量的复选框（大量的DOM对象）会影响渲染速度，过渡动画会变慢，取消以后，视觉上的反馈速度会快许多。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.el-checkbox__input</span><span class="selector-class">.is-checked</span> <span class="selector-class">.el-checkbox__inner</span>, <span class="selector-class">.el-checkbox__input</span><span class="selector-class">.is-indeterminate</span> <span class="selector-class">.el-checkbox__inner</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.el-checkbox__inner</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>对tab使用v-if和keep-alive</li>
</ol>
<ul>
<li>v-if控制不生成无需显示的虚拟DOM，这样在点击全局全选/取消全选（会影响所有tab的数据）的时候，不用去做其他tab的diff。</li>
<li>使用keep-alive的原因是使用v-if以后，切换tab会有较大的延迟（原因是有大量的DOM的创建），所以使用keep-alive缓存组件，除了第一次由于无缓存而比较迟缓外，后续的切换速度还是可以的。</li>
<li><strong>在keep-alive上最开始我犯了个错误，在keep-alive下面放div，发现并没有任何提升效果，看了文档发现keep-alive下面需要放自定义组件</strong></li>
<li>这个方案不太具通用性，但Vue没有<code>shouldComponentUpdate</code>的更新控制，不过也算是个可考虑的技巧。</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>前端框架虽然减少了开发者的工作量，但也有执行效率不那么高效的一面（需要遍历diff而不是直接命令式的指定某个DOM更新），为了给用户更好的用户体验，成为更好的开发者，需要在调优上多花点心思。</p>
<p>附：</p>
<ul>
<li>其实DOM的渲染也是影响性能的一个重要因素。这个论点的根据时，当我把所有tab的<code>display</code>设为<code>none</code>后，发现切换的速度会有很大的提升。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2020/04/19/optimization-techniques-for-better-performance-of-vue-app/" data-id="ck977iv810000d8u1e49j8835" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/Vue/">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/performance/">performance</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-experience-of-using-git-submodule" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2020/03/18/experience-of-using-git-submodule/" class="article-date">
  <time datetime="2020-03-18T01:18:32.233Z" itemprop="datePublished">2020-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2020/03/18/experience-of-using-git-submodule/">git submodule的使用经验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上两周开始，我开始在实际项目中使用之前同事提到过的<code>git submodule</code>的代码管理方式。</p>
<p>最开始我引入这个命令的原因是前端的各Vue项目之间，目录结构和代码内容相似，甚至于有时候新开一个项目会直接复制旧项目的代码。一言而蔽之，那就是项目之间有着可共用的代码模块。</p>
<p>假如把其中的一些子目录抽出来作为一个独立仓库，主项目只进行引用，就可以避免这些可共用的代码不可靠地进行人工复制，代码分散管理更新的问题。</p>
<h3 id="常用命令解释及易误解的地方"><a href="#常用命令解释及易误解的地方" class="headerlink" title="常用命令解释及易误解的地方"></a>常用命令解释及易误解的地方</h3><p>以下<strong>常用命令</strong>部分基本来自于<a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" target="_blank" rel="noopener">官方指南</a></p>
<p>克隆远程仓库作子模块<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add &lt;remote-repo-url&gt; [local-path=.]</span><br></pre></td></tr></table></figure></p>
<p>显示子模块的diff信息<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached --submodule</span><br></pre></td></tr></table></figure></p>
<p>克隆（<code>git clone</code>）带有子模块的项目后，需要初始化并拉取子模块<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line"><span class="meta">#</span> 上面两命令的组合，一般直接用组合命令</span><br><span class="line">git submodule update --init</span><br><span class="line"><span class="meta">#</span> 又或者加上 --recursive 拉取嵌套的子模块（子模块本身又有子模块）</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"><span class="meta">#</span> 或者在clone时加上 --recurse-submodules选项自动完成拉取</span><br><span class="line">git clone --recurse-submodules &lt;main-project-repo-url&gt;</span><br></pre></td></tr></table></figure></p>
<p>当需要更新子模块时，切换到子模块的目录，使用常规的拉取上游更新的命令<code>git fetch</code>和<code>git merge</code>（或直接<code>git pull</code>）<br>或直接使用<code>git submodule update --remote [submodule-path]</code>就不用切目录进行手动更新。</p>
<p>上面快捷命令默认拉取的是master分支，如果想默认拉取其他分支，则进行如下配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -f &lt;git-modules-config-path&gt; 表示指定.gitmodules文件路径</span></span><br><span class="line">git config -f .gitmodules submodule.&lt;submodule-name&gt;.branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></p>
<p>进行下面的配置，可以让git status显示子模块的status<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config status.submodulesummary 1</span><br></pre></td></tr></table></figure></p>
<p>当不想每次diff更新时都要添加submodule选项，可以进行如下配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global diff.submodule <span class="built_in">log</span></span><br></pre></td></tr></table></figure></p>
<p>类似于<code>git clone</code>，<code>git pull</code>如果要同时拉取子模块，也需要添加相关的选项<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull --recurse-submodules</span><br><span class="line"><span class="comment"># 或者分开进行</span></span><br><span class="line">git pull</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p>
<p>使用merge选项可以合并远程更新，如果不添加<code>--merge</code>，默认使用<code>--checkout</code>，直接检出commit。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --remote 选项的作用是假如子模块有追踪远程的分支，那将会拉取该上游分支进行同步，否则会检出主模块当前commit对应的子模块的commit</span></span><br><span class="line"> git submodule update --remote --merge</span><br></pre></td></tr></table></figure></p>
<p>如果发生冲突，可以跟普通仓库一样，到对应的子模块目录处理冲突，然后提交。由于子模块有新的提交（commit），回到主模块目录输入<code>git status</code>也会提示需要<code>git add</code>子模块的目录。</p>
<p>当在主仓库推送更新时可以使用<code>recurse-submodules</code>选项，避免没有推送子模块更新的情况。<strong>假如子模块更新没有推送到子模块的远程仓库，那么当其他成员，拉取主仓库时将会报错，提示不能从远程拉取对应的子模块的版本。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个只会提示你有子模块还没推送</span></span><br><span class="line">git push --recurse-submodules=check</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">git push --recurse-submodules=on-demand</span><br></pre></td></tr></table></figure></p>
<h4 id="在实践中出现的疑问"><a href="#在实践中出现的疑问" class="headerlink" title="在实践中出现的疑问"></a>在实践中出现的疑问</h4><p>Q1： <code>git submodule</code>跟直接<code>clone</code>子模块到子目录的区别在哪里。</p>
<p>A1：直接<code>clone</code>不能与主模块产生关联，而<code>git submodule</code>会在工程目录下添加<code>.gitsubmoules</code>文件，声明所有的子模块所在的目录及它们的远程仓库地址等相关信息。第二点，其实是理解<code>submodule</code>机制的关键，子模块不论因什么原因（未staged的change、untracked的文件、checkout到其他版本等）产生内容变化，在主模块目录输入<code>git status</code>都会显示子模块目录有更改。主模块在判断子模块是否有更改是与<strong>主模块当前版本对应的子模块版本</strong>进行比较。</p>
<p>主模块在<code>git add</code>文件时是不会添加子模块目录下的内容，而是直接<code>add</code>子模块目录。子模块目录以主模块的角度来看，是一个记录版本号的<code>.txt</code>文件，记录的版本号与子模块当前版本同步。</p>
<p>这一点可以在主模块拉取远程更新，子模块目录发生冲突的时候可以体现。显示的冲突会显示成类似下面的形式，下面的英文字符是commit的SHA:<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; a/src/components (Current Change)</span><br><span class="line"><span class="comment">+++ abcdefghijklmnopqrst</span></span><br><span class="line">&gt;&gt;&gt; b/src/components (Incoming Change)</span><br><span class="line"><span class="comment">+++ ghijklmnopqrstuvwxyz</span></span><br></pre></td></tr></table></figure></p>
<p>Q2：怎么把分支B的子目录变成子模块，假设分支A的该子目录已经是子模块了。</p>
<p>A2：切到分支B，然后checkout 分支A的<code>.gitmodules</code>文件（注意这里如果直接初始化(<code>git submodule update --init</code>)子模块是无效的，道理可参见上一个问题的解释，因为此时子模块没有指定一个版本）。切到分支B后，有两种方式完成这个任务：</p>
<ol>
<li>删除子目录的内容，通过 <code>git submodule add</code> 克隆远程仓库到指定子目录</li>
<li><code>checkout</code>分支A的<code>.gitmodules</code>文件（注意这里如果直接初始化(<code>git submodule update --init</code>)子模块是无效的，道理可参见上一个问题的解释，因为此时子模块所在目录没有任何记录为子模块的历史，没有版本绑定）。然后checkout 分支A的对应子目录即可。</li>
</ol>
<h3 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h3><ul>
<li><p>submodule下有一个<code>foreach</code>的子命令挺实用的，它的机制类似于<code>cd</code>到每个子模块目录，然后执行一段shell脚本。</p>
<ul>
<li>example：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示各个子模块的status</span></span><br><span class="line">git submodule foreach <span class="string">'git status'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>官方指南上记载了三个<code>git alias</code>的配置，可以使用缩写执行一些常用命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ! 表示命令可以是普通的shell命令而不用是git 的子命令</span></span><br><span class="line"><span class="comment"># 在windows中需要把'!'"git diff ..." 改成 "! git diff ..."</span></span><br><span class="line">git config alias.sdiff <span class="string">'!'</span><span class="string">"git diff &amp;&amp; git submodule foreach 'git diff'"</span></span><br><span class="line">git config alias.spush <span class="string">'push --recurse-submodules=on-demand'</span></span><br><span class="line">git config alias.supdate <span class="string">'submodule update --remote --merge'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="附记"><a href="#附记" class="headerlink" title="附记"></a>附记</h3><p>最开始公司里提出用<code>submodule</code>并不是为了共用代码，而是为了在前后端代码并存的项目中，对前后端代码分别使用子模块管理，进行分隔，互不干涉。</p>
<p>对于共用代码的方案，git还有一个好像在某些版本不是内置的命令<code>subtree</code>，稍微了解了一下，好像<code>subtree</code>会把子模块的内的文件更改也记录到主模块中。个人觉得<code>submodule</code>的对于各模块的分割功能更好，而且是<code>git</code>内置的，算是标准功能吧。</p>
<p>虽然<code>submodule</code>的使用需要一点额外的学习成本，但只要了解了它的机制，用起来也能得心应手的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2020/03/18/experience-of-using-git-submodule/" data-id="ckbxv4jl70000e0u1w9pnlpcx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/git/">git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/submodule/">submodule</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-yox-research-template-expression-episode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2020/02/23/yox-research-template-expression-episode/" class="article-date">
  <time datetime="2020-02-23T14:42:49.525Z" itemprop="datePublished">2020-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2020/02/23/yox-research-template-expression-episode/">Yox框架研究（1）—模板表达式编译篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>在google上搜索 <strong>“vue不能兼容IE8”</strong>，在知乎上看到Yox的作者在推他写的这个框架。这个框架的特点是属性方法设计基本与<code>vue</code>一致，模板语法参照<code>handlebar</code>，能兼容IE6以上的浏览器。<br>值得一提的是，Yox的作者对自己的作品很有自信，且声称该框架一直用在自己的工作中。</p>
<p>阅读框架源码，发觉他的自信是有道理的，理由有:</p>
<ol>
<li>代码使用typescript编写</li>
<li>代码组织清晰，变量命名简单易懂，少新造概念，并且有足够的注释</li>
<li>有独特的设计，如使用<code>handlebar</code>的模板语法，在列表渲染中有类似变量作用域的语法设计（<code>&quot;../name&quot;</code>表示使用上一层的name属性）</li>
<li>整个框架基本由他一人开发</li>
</ol>
<p>因为有这些特点，让我觉得这是一个值得深入学习的项目。</p>
<h3 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h3><p><strong>模板编译</strong>的工作是把模板字符串转成函数代码，我看过的一些模板引擎<code>ejs</code>，<code>pug</code>，<code>vue</code>，<code>yox</code>都是同样的做法。<br><code>yox</code>把模板表达式的编译部分拆分成独立的模块(<code>yox-expression-compiler</code>)，整个模板的编译为<code>yox-template-compiler</code>模块。</p>
<p><code>yox-expression-compiler</code>模块包含了三个感觉比较重要的概念：</p>
<ol>
<li>compiler：解析表达式</li>
<li>creator：创建组成表达式的各类节点，如字面量、标识符、函数调用节点</li>
</ol>
<p>节点，其实就是结构对象：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLiteral</span>(<span class="params">value: <span class="built_in">any</span>, raw: <span class="built_in">string</span></span>): <span class="title">Literal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: nodeType.LITERAL,</span><br><span class="line">    raw,</span><br><span class="line">    value,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>generator: 将节点转换成代码字符</li>
</ol>
<p>creator和generator相对来说没那么复杂，而compiler则负责代码扫描解析逻辑的任务。</p>
<h4 id="compiler的设计"><a href="#compiler的设计" class="headerlink" title="compiler的设计"></a>compiler的设计</h4><ol>
<li>游标移动<ol>
<li><code>go</code>：前进后退</li>
<li><code>skip</code>: 跳过空白字符</li>
</ol>
</li>
<li>token类型判断——<code>scanToken</code>，有下列情况：<ol>
<li>identifier（标识符，如<code>a</code>, <code>name</code>）</li>
<li>literal（字面量）<ol>
<li>number</li>
<li>字符串</li>
<li>数组</li>
<li>对象</li>
</ol>
</li>
<li>一元运算符（二元运算符的提取会在<code>scanBinary</code>）</li>
<li>特殊字符  <ol>
<li><code>(xx)</code>，括号</li>
<li><code>.</code>,<code>../</code>，表示上面提到的作用域切换或者<code>&#39;.&#39;</code>开头的数字</li>
</ol>
</li>
</ol>
</li>
<li>运算式的解析——<code>scanTernary</code>、<code>scanBinary</code></li>
</ol>
<h5 id="其他规则："><a href="#其他规则：" class="headerlink" title="其他规则："></a>其他规则：</h5><ol>
<li><strong>当遇到idenfier或者字面量</strong>（除<strong>number</strong>和<strong>对象</strong>外），还会进行<code>scanTail</code>逻辑（意思式检测后面是否接着<code>.</code>，<code>[]</code>这样的取成员的表达式以及<code>(a,b,c)</code>这样可能的函数调用表示，如果有则会组成一个新的节点）</li>
<li><strong>当下一个接的值是可能的任意值时（如对象的属性值，数组的成员，函数参数）</strong>，都会调用<code>scanTernary</code>,所以在启动编译时，第一步就是执行这个方法。可能的解释是<strong>三元表达式</strong>是包含内联代码所有可能的<strong>表达式</strong>，所以先假定是<strong>三元表达式</strong>，如果不符合条件再fallback到其余情况。</li>
</ol>
<h5 id="比较有启发性的解析方法："><a href="#比较有启发性的解析方法：" class="headerlink" title="比较有启发性的解析方法："></a>比较有启发性的解析方法：</h5><ol>
<li>对象解析:<br>对象分为key和value，所以在解析时会在<code>key</code>和<code>value</code>两个模式中进行切换，初始时<code>key</code>，遇到<code>:</code>转<code>value</code>，遇到<code>,</code>转<code>key</code>。解析到<code>key</code>和<code>value</code>时，会分别添加到<code>keys</code>和<code>values</code>数组。当遇到<code>}</code>闭合字符时，根据两个数组中成员的个数，判断对象是否合法。</li>
<li><p>二元运算式解析：<br>运算式由<strong>运算数（operand）</strong>和<strong>运算符（operator）</strong>组成，先解析运算数后解析运算符，而二元运算符有优先级的问题（<code>a + b * c + d</code>，应该先运算<code>b * c</code>）。</p>
<p>解决的方法为源码中提到的<a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm" target="_blank" rel="noopener">Shunting-yard algorithm</a></p>
<p>中心思想是，<strong>运算数</strong>和<strong>运算符</strong>会按顺序<code>push</code>到数组中，确保扫描到的当前运算符的优先级小于前一个运算符，否则则将前一个二元运算提出来作为一个新的<code>Node</code>（如上面<code>+ d</code>的<code>+</code>）</p>
<p>（中文译作调度场算法，一种将中缀表达式<code>a + b</code>转成后缀表达<code>a b +</code>的算法，之前好像有在线上课程中提到过，应该是计算机系的课程内容。</p>
<p>wiki上说中缀表达式不易被电脑识别，但感觉这不构成在这里使用这个算法的理由，毕竟似乎 <strong>“假如当前运算符的优先级高于前一个，则将后面的二元运算式提出”</strong>也行得通。不过可能这样的话，由于还不知道下一个操作数，不好做处理，所以选用了这个算法）。</p>
<p>当后面不再有二元运算式时，再从<strong>数组</strong>后面取出组成一个个的二元运算式节点。</p>
</li>
</ol>
<h3 id="compiler的阅读体会"><a href="#compiler的阅读体会" class="headerlink" title="compiler的阅读体会"></a>compiler的阅读体会</h3><ol>
<li>对于代码表达式来说，通常都会有开始标志和结束标志的这样成对的设计，如html标签<code>&lt;div&gt;&lt;/div&gt;</code>，字符串<code>&#39;a&#39;</code>,<code>&quot;abc&quot;</code>，对象<code>{ a: 1 }</code>，数组<code>[ 1, 2, 3 ]</code>,函数参数<code>(1, 2, 3)</code>。</li>
<li>之前觉得像对象那样的嵌套结构挺难处理的，但事实上这种情况完全符合递归的场景，只需要再调用根函数即可，像上面说的<code>scanTernary</code></li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>下一篇应该是关于整个<code>template</code>编译的学习。现在开始需要多学习框架或者大项目的设计模式，这样才能学会独立从零到一开发项目。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2020/02/23/yox-research-template-expression-episode/" data-id="ck6z56kmn00000su174pvrzdp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/Yox/">Yox</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/compile/">compile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/expression/">expression</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/framework/">framework</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/mvvm/">mvvm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/template/">template</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vue-ssr-demo-following-official-guide" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2020/02/01/vue-ssr-demo-following-official-guide/" class="article-date">
  <time datetime="2020-02-01T14:39:24.094Z" itemprop="datePublished">2020-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2020/02/01/vue-ssr-demo-following-official-guide/">按照官方指南实践vue SSR</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>年末跟新公司的同事聊过node中间件和服务端渲染的问题，大概的意思就是将原来nginx的特定路由的分发，交由我们前端组负责，使用node代替的想法，希望前端组能够不依赖后端的同学，独立完成一些服务端的工作，方便后面去做服务端渲染。<br>于是，趁着春节假期，在家里花点时间，做一下vue的服务端渲染的实践。</p>
<h2 id="实践笔记"><a href="#实践笔记" class="headerlink" title="实践笔记"></a>实践笔记</h2><p>由于之前的项目一般都是通过vue-cli去生成的，所以初步的想法是思考将已有项目改为SSR的方法。<br>于是实践便由<code>vue create ssr-demo</code>命令生成的项目开始了。<br>第一步，一般是去查看<a href="https://ssr.vuejs.org/guide/" target="_blank" rel="noopener">官方指南</a>。可喜的是，在某一页中看到了一个官方demo的<a href="https://github.com/vuejs/vue-hackernews-2.0" target="_blank" rel="noopener">github链接</a>，有示例项目作为参照，认识会更具体一些。</p>
<p><strong>SSR大体来说是用同一份代码，分别以server环境和client环境为目标做两次打包（具体来说可以是使用两份配置，运行两次webpack），server端收到请求运行对应环境的bundle，render出html，发回client端；而html里包含了client环境bundle的script，css资源的链接。加载完script以后会hydrate（激活）服务器渲染出来的app的html（如给DOM添加listener）。</strong></p>
<p>所以在改造项目时，<strong>需要意识到server环境和client环境的API的不同</strong>。<br><strong>改造过程中已知的两个环境的不同点有：</strong></p>
<ol>
<li>server端在渲染component时，生命周期只会进行到<code>created</code>，所以最好是做到<strong>全局</strong>和周期<code>created</code>之前的代码是环境通用的代码。</li>
<li>需要预获取的数据的component，可以在构造options提供<code>serverPrefetch</code>的option，这是一个this指向vue instance的function，如果返回一个promise，会等这个promise resolved后再去做component的render。</li>
<li>client端的bundle的webpack config一般可能会加splitChunks来做代码分割，可是server端的bundle则需要将所有代码打包成一块，所以不做代码分割。</li>
<li>server端的入口文件需要export一个接收ssr context对象，返回可resolve出app实例的promise。</li>
<li>server端需要添加<code>VueSSRServerPlugin</code>，webpack打包最终生成一个json；client端则添加<code>VueSSRClientPlugin</code>，除了生成的js，css等文件以外，还会生成一个<code>client-manifest</code>的json文件（用于提供生成的文件的信息，让服务端渲染的html能够正确插入client端生成文件资源的标签）。</li>
<li>server端的配置还需要在<code>DefinePlugin</code>中加上<code>Process.env.VUE_ENV=&#39;server&#39;</code>的配置。</li>
</ol>
<p><strong>共同点</strong></p>
<ol>
<li>由于生成的html由服务端渲染而成（或者说由服务端渲染负责），所以原有的htmlWebpackPlugin也去掉。而prefetch，preload和pwa的插件依赖于htmlWebpackPlugin，所以在配置中都要去掉。</li>
</ol>
<p><strong>遇到的问题和解决方法</strong></p>
<ol>
<li>vue-cli生成的项目，除非释出webpack的配置，否则都是通过创建的vue.config.js对webpack进行调整。而当在开发的时候，因为不去用默认的webpack的devServer，所以需要获取根据vue.config.js生成的webpack配置。而<code>@vue/cli-service/lib/Service</code>的Service实例提供了一个<br><code>resolveWebpackConfig</code>的方法，去得到相应的wepack配置。</li>
<li>第二个问题时<code>1</code>中的Service实例怎么找到对应的vue.config.js文件呢？现在有client和server两个config，需要动态替换vue config来生成webpack配置。通过阅读网上方案和<code>@vue/cli-service/lib/Service</code>的源代码，得知可在创建Service实例前，通过改变<code>process.env.VUE_CLI_SERVICE_CONFIG_PATH</code>为对应<code>vue.config.js</code>的<strong>绝对路径</strong>，便可实现动态切换需求。</li>
<li><code>1</code>中提到需要自己去写一个devServer，主要就是要实现打包资源请求的响应和模块热更替。修改的关键是添加<code>webpack-dev-middleware</code>,<code>webpack-hot-middleware</code>和<code>HotModuleReplacementPlugin</code>。<ol>
<li><code>webpack-dev-middleware</code>的功能是处理打包资源请求的响应，同时也把compiler的fileSystem改为<code>memory-fs</code>（将打包的文件缓存在内存里），如果有与请求匹配的打包后的asset，则将之返回。</li>
<li><code>webpack-hot-middleware</code>的是做监听webpack的recompile事件，然后通知客户端的工作。</li>
<li><code>HotModuleReplacementPlugin</code>则是给文件的<code>module</code>添加<code>hot</code>的属性，提供一些关于请求更新后的模块资源等API，<code>webpack-hot-middleware</code>包含了这些API的使用，所以一般不需要自行配置。</li>
</ol>
</li>
<li>虽然<code>3</code>中的<code>webpack-hot-middleware</code>帮忙处理了webpack的recompile的模块更新问题，不过还有一个<code>index.template.html</code>文件需要做热更新，在这里是使用<code>chokidar</code>做文件更新监听，再利用<code>webpack-hot-middleware</code>的<code>publish</code>方法通知客户端。</li>
<li>到了生成<code>production</code>环境文件的时候，依然还是使用vue-cli进行生成，所以像<code>2</code>中所述，需要在<code>package.json</code>的script中填写<code>vue.config.js</code>的<strong>绝对路径</strong>。跨平台的环境变量设置可以使用<code>cross-env</code>，但是要得到这个<strong>绝对路径</strong>，需要知道<strong>工作目录</strong>。但是在不同平台的<strong>工作目录变量</strong>的名字可能不一样，所以这里使用了<code>$INIT_CWD</code>这个变量。<code>$INIT_CWD</code>指的是<strong>npm指令运行时的工作目录</strong>。</li>
<li>当我尝试做组件的<strong>Data Prefetch</strong>时，使用了<code>&#39;/topNews&#39;</code>这个相对的url，在client端是没问题的，会带上host和port，但是在server端，他没有这个context，如果是用相对的url，host会是localhost（这个没有问题），但是<strong>port会是默认的80</strong>，所以需要在axios那里根据是否是server环境，去加上如<code>http://localhost:8080</code>的前缀。</li>
</ol>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>项目放在<a href="https://github.com/Sociosarbis/vue-ssr-demo" target="_blank" rel="noopener">github</a>，大部分参考自官方的demo，已完成项目框架的搭建。后面假如说真的有需要的话，再进一步完善本项目。<br>后面可做的有:</p>
<ol>
<li>做成vue-cli的preset，一件生成目录结构。</li>
<li>添加server的proxy和cache功能。</li>
<li>配置作为业务模块分发的路由。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2020/02/01/vue-ssr-demo-following-official-guide/" data-id="ck64y70vs000fjgu1ohoowycr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/SSR/">SSR</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2D-bin-packing-algorithm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2020/01/01/2D-bin-packing-algorithm/" class="article-date">
  <time datetime="2020-01-01T14:19:37.109Z" itemprop="datePublished">2020-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2020/01/01/2D-bin-packing-algorithm/">一种2D装箱算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间在做项目的时候，遇到某组图标需要从iconfont改为使用png的情况。这种情况，由于图标本身是比较小的而数量又比较多，为了减少大量http请求的成本，需要把这些图标做成一张sprite图。在不劳烦UI的同学的情况下，那我自行去生成了。<br>本身就有一些现成的网站有这类的服务了，如<a href="https://www.toptal.com/developers/css/sprite-generator" target="_blank" rel="noopener">toptal.com</a>；命令行的话，有spritesmith。其中里面的有一个叫binary-tree的排列方式引起我的兴趣，查看spritesmith的源码，他其实是用了<a href="https://github.com/bryanburgers/bin-pack" target="_blank" rel="noopener">bin-pack</a>提供的算法的。下面开始介绍这种算法。</p>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>把图片数组按照它们的面积大小，从大到小排列，并把最大的那张图片放到左上角，并把他的x,y,width,height作为初始root的数值</li>
<li>遍历所有的图片，一个个对他们进行放置。</li>
<li>放置的规则是从root出发，<ol>
<li>如果<strong>当前遍历的图片的width和height都不大于当前node</strong>（<strong><em>条件1</em></strong>）， 把<strong>当前的遍历的图片A</strong>放在<strong>node</strong>的左上角, 然后进行<strong>分裂</strong>操作，给<strong>node</strong>添加<strong>down</strong>和<strong>right</strong>两个<strong>子node</strong>, 分别未A的<strong>右上方</strong>到node的<strong>右下方</strong>和<br>A的<strong>左下方</strong>到node的<strong>右下方</strong>两个区域。</li>
<li>第1步中用的是<strong>当前node</strong>这个词的原因是，假如<strong>一个node（包括root）分裂过</strong>，那么第一步就会从<strong>他的down或者right的子node</strong>中，寻找具有足够空间放置的一方（是一个递归的过程）。</li>
<li>假如不满足<strong>条件1</strong>，root就会进行<strong>grow</strong>操作，<strong>grow</strong>在放置新图片在右方还是下方的问题上会考虑两个因素：<ol>
<li>如果新图片的宽小于root的宽表示可以向下增长，高小于root的高，表示可以向右增长。</li>
<li>第二个是非必要因素，主要是遵循增长以后root的宽高，差距能缩小的原则。假设第1步显示两个方向都允许的，但如果往右增长，高依然是大于宽的，那就会优先往右增长。<strong>增长</strong>分别就相当于在root的右上角和左下角，放置新的那个图片。同时根据放置的位置，更新root的<strong>right或者down 子node的位置和大小</strong>。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>在bin-pack的github上也提到了这个算法提供的并不是最优解，但是算法十分简洁，效果也能在使用它的库中得到体现，可以说是相当实用的，也给我们在解决这类问题的时候，提供了一个行之有效的方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2020/01/01/2D-bin-packing-algorithm/" data-id="ck64y70us0000jgu1aolk7ih0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/bin-pack/">bin-pack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/sprite/">sprite</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-from-whistle-hot-reload-plugin-develoment-to-websocket-mechanism" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/12/27/from-whistle-hot-reload-plugin-develoment-to-websocket-mechanism/" class="article-date">
  <time datetime="2019-12-26T16:36:40.565Z" itemprop="datePublished">2019-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2019/12/27/from-whistle-hot-reload-plugin-develoment-to-websocket-mechanism/">从whistle热重载插件到websocket工作原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>工作上有些需求是需要去改后端渲染的文件的，但是由于不是通过webpack开发，没有修改完立刻更新页面的功能，所以显得不是太方便。要实时更新页面可以通过热重载或热更新，热重载比较简单，其实就是页面自动reload，热更新则需要重新打包已更改的文件，然后通过websoket发送新的补丁，完成更改。 </li>
</ul>
<h3 id="需要实现的功能"><a href="#需要实现的功能" class="headerlink" title="需要实现的功能"></a>需要实现的功能</h3><ul>
<li>先不谈复杂的热更新，对于后端渲染的这类比较简单的页面，热重载已经能够很好地方便我们的开发了。</li>
<li>要做热重载，需要做以下两个功能：<ol>
<li>监听文件的更改</li>
<li>通知页面进行reload</li>
</ol>
</li>
<li>第一点比较简单，可以使用<a href=""><code>fs.watch</code></a>或者跨平台的库<a href="https://www.npmjs.com/package/chokidar" target="_blank" rel="noopener"><code>chokidar</code></a>，都可以进行对文件更改的监听。</li>
<li>第二点对页面进行通知，我们平时用webpack开发的时候自然会发现页面会打开一个websocket的连接，而这个连接就是起服务器与页面客户端间通信的作用。</li>
</ul>
<h3 id="websocket的工作流程"><a href="#websocket的工作流程" class="headerlink" title="websocket的工作流程"></a>websocket的工作流程</h3><ul>
<li>下一步就是怎么创建一个websokcet的连接的问题，分为两个部分，server和client</li>
<li>client：<ul>
<li>对于比较简单的应用，例如这种通知更新的，可以简单地使用浏览器提供的<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank" rel="noopener"><code>Websocket</code></a>的api</li>
</ul>
</li>
<li><p>sever：</p>
<ul>
<li>首先node没有提供直接的api，可以用第三方库或者自己实现。对于第三方库，比较著名的有<code>socket.io</code>，不过需要在页面中使用客户端对应的库，所以不作考虑。而留意到webpack-dev-server用到的库是<code>sockjs-node</code>， 使用浏览器的api就可完成连接，所以这里就选用该库。</li>
<li><p>先来看一下简单用例①:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> sockjs = <span class="built_in">require</span>(<span class="string">'sockjs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> echo = sockjs.createServer(&#123; <span class="attr">prefix</span>:<span class="string">'/echo'</span> &#125;);</span><br><span class="line">echo.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">conn</span>) </span>&#123;</span><br><span class="line">conn.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    conn.write(message);</span><br><span class="line">&#125;);</span><br><span class="line">conn.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line">echo.attach(server);</span><br><span class="line">server.listen(<span class="number">9999</span>, <span class="string">'0.0.0.0'</span>);</span><br></pre></td></tr></table></figure>
<p>如果了解过node.js，<code>http.createServer</code>的作用是创建一个http的服务器，那为什么又有一个类似的<code>sockjs.createServer</code>的方法，难道真的是创建多一个服务器吗？<br>带着这个疑问，翻看源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">events</span>.<span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(user_options) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.options = <span class="built_in">Object</span>.assign(</span><br><span class="line">        &#123;</span><br><span class="line">            prefix: <span class="string">''</span>,</span><br><span class="line">            transports: [</span><br><span class="line">            <span class="string">'eventsource'</span>,</span><br><span class="line">            <span class="string">'htmlfile'</span>,</span><br><span class="line">            <span class="string">'jsonp-polling'</span>,</span><br><span class="line">            <span class="string">'websocket'</span>,</span><br><span class="line">            <span class="string">'websocket-raw'</span>,</span><br><span class="line">            <span class="string">'xhr-polling'</span>,</span><br><span class="line">            <span class="string">'xhr-streaming'</span></span><br><span class="line">            ],</span><br><span class="line">            response_limit: <span class="number">128</span> * <span class="number">1024</span>,</span><br><span class="line">            faye_server_options: <span class="literal">null</span>,</span><br><span class="line">            jsessionid: <span class="literal">false</span>,</span><br><span class="line">            heartbeat_delay: <span class="number">25000</span>,</span><br><span class="line">            disconnect_delay: <span class="number">5000</span>,</span><br><span class="line">            log() &#123;&#125;,</span><br><span class="line">            sockjs_url: <span class="string">'https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        user_options</span><br><span class="line">        );</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>.handler = webjs.generateHandler(<span class="keyword">this</span>, listener.generateDispatcher(<span class="keyword">this</span>.options));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它并没有做任何与连接相关的工作。然后再看到用例①中对于sockjs创建的这个<strong>“server”</strong> ，还有一步是<code>echo.attach(server)</code>，看来这里才是<strong>“sockjs sever”</strong>工作的入口。源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">attach(server) &#123;</span><br><span class="line">    <span class="keyword">this</span>._rlisteners = <span class="keyword">this</span>._installListener(server, <span class="string">'request'</span>);</span><br><span class="line">    <span class="keyword">this</span>._ulisteners = <span class="keyword">this</span>._installListener(server, <span class="string">'upgrade'</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>原来是对<strong>http server</strong>的<strong>request</strong>和<strong>upgrade</strong>事件做监听。<br><strong>request</strong>是收到http请求时触发的，那<strong>upgrade</strong>呢？</p>
<h4 id="根据node的文档所述："><a href="#根据node的文档所述：" class="headerlink" title="根据node的文档所述："></a>根据node的文档所述：</h4><blockquote>
<p>Emitted each time a server responds to a <strong>request with an upgrade</strong>. </p>
</blockquote>
<p>这里的<strong>request with an upgrade</strong>，通过后面的example，粗浅地可以认为是<strong>Connection</strong> header为<code>&#39;Upgrade&#39;</code>，并且还有一个<code>Upgrade</code>header的<strong>request</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    ...</span><br><span class="line">    headers: &#123;</span><br><span class="line">    <span class="string">'Connection'</span>: <span class="string">'Upgrade'</span>,</span><br><span class="line">    <span class="string">'Upgrade'</span>: <span class="string">'websocket'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> req = http.request(options);</span><br></pre></td></tr></table></figure>
</li>
<li><p>request事件的callback参数为<strong>request和response</strong>，而upgrade事件则是<strong>request，socket和head</strong>。第二个参数由<strong>response变为socket</strong>，而这个socket参数就是client和server间的TCP连接，而<strong>websocket</strong>就是对这个<strong>TCP连接的socket对象</strong>进行操作，根据<strong>websocket</strong>协议的规则，对<strong>socket</strong>对象中通信的数据进行解析读入和封装用户的消息进行写入。</p>
</li>
<li><p>顺带一提，对于要upgrade为websocket的请求，服务端也会写入符合http规则的响应报文（而这个过程称作建立websocket连接的握手），并且不会调用<code>response.end或者说socket.end</code>去结束服务端和客户端的连接。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.write(<span class="string">'HTTP/1.1 101 Web Socket Protocol Handshake\r\n'</span> +</span><br><span class="line">    <span class="string">'Upgrade: WebSocket\r\n'</span> +</span><br><span class="line">    <span class="string">'Connection: Upgrade\r\n'</span> +</span><br><span class="line">    <span class="string">'\r\n'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>ps：</strong>建立websocket的request还会有<code>sec-websocket-version</code>和<code>sec-websocket-key</code>等headers，而response还会有<code>sec-webSocket-accept</code>等headers，由于本文主旨在于建立websocket的通信流程的概念，所以具体的协议标准等知识，可自行search。</p>
</li>
<li><p>建立了websocket的连接，下面就是要知道是怎么从socket收到消息和写消息到socket中。这两个步骤对应于这两行来自<strong>faye-websocket\lib\faye\websocket\api.js</strong>的代码(<strong>faye-websocket</strong>是<strong>sockjs-node</strong>的依赖库)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._stream.pipe(<span class="keyword">this</span>._driver.io);</span><br><span class="line"><span class="keyword">this</span>._driver.io.pipe(<span class="keyword">this</span>._stream);</span><br></pre></td></tr></table></figure>
<p><code>this._stream</code>就是TCP的<code>socket</code>（也是流对象），而<code>this._driver.io</code>是一个双工(Duplex, 意为可读可写)的流。<br><strong>ps:</strong>流就是nodejs的Stream类。</p>
</li>
<li>之前我看到pipe这个方法，对他的机制有点摸不着头脑，不知道他是在什么时候才会把数据传到<strong>可写流（Stream.Writable）</strong>中。要解决这个疑问，只需要看到这一步，就知道触发<strong>可读流(Stream.Readable)</strong>的<code>data</code>事件时，就会把数据写到可写流中。而data事件的其中一个触发时机，就在Readable的read方法中。而pipe方法在最后，会通过resume方法，让流进入<strong>flowing</strong> mode，这个mode简单来讲就是假如Readable的<strong>Internal buffer(内部缓存)</strong>，就会通过循环不断地调用read。<h5 id="最后一个疑问他内部缓存地数据又是从哪里来的呢？"><a href="#最后一个疑问他内部缓存地数据又是从哪里来的呢？" class="headerlink" title="最后一个疑问他内部缓存地数据又是从哪里来的呢？"></a>最后一个疑问他内部缓存地数据又是从哪里来的呢？</h5>答案是在<code>read</code>方法中，会调用<code>_read</code>方法。<code>_read</code>方法的作用是调用<code>Readable.push</code>方法，把数据放到<strong>Internal buffer</strong>里。可能这也是为什么在继承或者实现Readable的时候，需要去实现一个<code>_read</code>方法来获取自定义数据。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/nodejs/node/blob/master/lib/_stream_readable.js</span></span><br><span class="line">src.on(<span class="string">'data'</span>, ondata);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> ret = dest.write(chunk);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!state.flowing) &#123;</span><br><span class="line">    debug(<span class="string">'pipe resume'</span>);</span><br><span class="line">    src.resume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dest;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="websocket的内容就介绍到这里，下面是要讲的是完成热重载需求的whistle插件的开发。"><a href="#websocket的内容就介绍到这里，下面是要讲的是完成热重载需求的whistle插件的开发。" class="headerlink" title="websocket的内容就介绍到这里，下面是要讲的是完成热重载需求的whistle插件的开发。"></a>websocket的内容就介绍到这里，下面是要讲的是完成热重载需求的whistle插件的开发。</h4><p>为了更好地理解下面的内容，可先阅读whistle文档中<a href="https://wproxy.org/whistle/plugins.html" target="_blank" rel="noopener"><strong>插件开发</strong></a>的部分。</p>
<p>如下是我在看过文档，github上的demo和whistle的源码后的几点所得。</p>
<ol>
<li>whistle的插件实际上就是让插件export一个接收<strong>server对象的函数</strong>, 然后自己编写对<strong>server对象</strong>事件响应的callback，事件主要是request和connect，request就是普通的http请求，connect可以是websocket或者tunnel请求(<em>ps:没了解过tunnel请求</em>)</li>
<li><p><strong>每个插件都会创建一个监听本地新端口的入口server，其主要的作用是把请求分发给它其下的子server，而这些server虽然都是真的http server，但它们不会监听端口，在请求的不同阶段，入口server会把请求分发到对应的子server</strong>，子server有如下这些：</p>
<ol>
<li>uiServer</li>
<li>reqRead</li>
<li>reqWrite</li>
<li>resRead</li>
<li>resRulesServer</li>
<li>resStatsServer</li>
<li>resWrite</li>
<li>rulesServer</li>
<li>server</li>
<li>statsServer</li>
<li>tunnelReqRead</li>
<li>tunnelReqWrite</li>
<li>tunnelResRead</li>
<li>tunnelResWrite</li>
<li>tunnelRulesServer</li>
<li>wsReqRead</li>
<li>wsReqWrite</li>
<li>wsResRead</li>
<li><p>wsResWrite<br>但问题是具体需要怎么响应对这些server的请求事件，文档里没有说明。只能在提供的demo中找到，某些server具体需要response什么东西。<br>例如<code>&#39;rulesServer&#39;</code>结尾的server，需要response如下的JSON数据来动态地去添加whistle的规则。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    rules: <span class="string">`<span class="subst">$&#123;req.headers.host&#125;</span>/sw-register.js file://&#123;sw-register&#125;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;req.headers.host&#125;</span>/sw.js file://&#123;sw-content&#125;`</span>,</span><br><span class="line">    values: &#123;</span><br><span class="line">        <span class="string">'sw-register'</span>: registerContent,</span><br><span class="line">        <span class="string">'sw-content'</span>: content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">null</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p><strong>rules</strong>是whisle规则的文本，<strong>values</strong>则是用于替换规则中的变量。<br>所以如果我们需要给我页面注入，websocket client的代码的话就在ruleServer中<code>response.end(rules)</code>就可以实现了。</p>
</li>
</ol>
</li>
<li>规则的值，如<code>www.ifeng.com method://post</code>中的<code>post</code>，可通过<code>req.originalReq.ruleValue</code>获取。</li>
<li>server当中有两个比较特别的，一个是<strong>uiServer</strong>，需要写一个完整的有前端页面的web应用，让用户修改插件的配置，给其他server去获取使用。另外一个是上面<strong>No.9的”server”</strong>，这个相当于一个代理的服务器，他的response会成为最后whistle传回来的那个response，其他的如ruleServer，就只是像上面说的只是通过resposne来增加一些临时的新规则。</li>
<li>*Read,*Write这两种结尾的server，本人到目前为止还不清楚到底要怎么用。</li>
</ol>
<h3 id="下面是这个插件简单的实现代码："><a href="#下面是这个插件简单的实现代码：" class="headerlink" title="下面是这个插件简单的实现代码："></a>下面是这个插件简单的实现代码：</h3><p><a href="https://github.com/Sociosarbis/whistle.hot-reload-plugin" target="_blank" rel="noopener">whistle.hot-reload-plugin</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>虽然这个功能很简单，但是它涉及到的知识还是很多的，而且还没有完全弄明白， 后面继续学习。</li>
<li>whistle的代码目前对我来说还是比较复杂的，涉及到协议的不同规则，请求转发， stream pipe等web后端的知识。 </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/12/27/from-whistle-hot-reload-plugin-develoment-to-websocket-mechanism/" data-id="ck64y70xy003fjgu1zri58cwj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/hot-reload/">hot-reload</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/plugin/">plugin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/stream/">stream</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/websocket/">websocket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/whistle/">whistle</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HTML-parser-and-querySelector" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/11/13/HTML-parser-and-querySelector/" class="article-date">
  <time datetime="2019-11-13T08:49:36.794Z" itemprop="datePublished">2019-11-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2019/11/13/HTML-parser-and-querySelector/">HTML parser和querySelector实现分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>最近在学习React Native的开发，把web端的网站转成app，由于部分api的缺失，需要从web的HTML里提取信息，那么就需要一个解析HTML的工具。</li>
<li>cheerio就是其中一个有名的库，但遗憾的是cheerio本身不支持在React Native环境运行。</li>
<li>记得之前看过微信团队的一个开源项目<a href="https://github.com/wechat-miniprogram/kbone" target="_blank" rel="noopener">kbone</a>是通过在小程序中模拟浏览器环境让面向web端开发的应用也能运行在小程序中。里面就包含了<strong>HTML parser</strong>和<strong>querySelector</strong>的实现，这两个的实现主要是<br>参考了<a href="https://johnresig.com/files/htmlparser.js" target="_blank" rel="noopener">HTMLParser</a>和<a href="https://github.com/jquery/sizzle/tree/master" target="_blank" rel="noopener">Jquery的sizzle</a>。</li>
<li>具体实现可以到上面的仓库查看相关代码，下面介绍实现的主要逻辑</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><strong>HTML parser</strong><ol>
<li>建立一个栈stack </li>
<li>抛开正则表达式不讲，最重要的逻辑是把遇到的<strong>开始标签(opening tag)</strong>时，会做如下操作：<ol>
<li>如果栈不为空，就<strong>把新的标签加到栈顶的children数组</strong>中</li>
<li>把它<strong>存到stack</strong></li>
</ol>
</li>
<li>当遇到<strong>结束标签(closing tag)</strong>时，把stack中相同类型的标签压出</li>
</ol>
</li>
<li><strong>querySelector</strong><ol>
<li>初始的时候，遍历parser解析出的HTML tree，把node的id，class和tag分别加入到<strong>idMap</strong>, <strong>classMap</strong>，<strong>tagMap</strong>中</li>
<li>selector的解析，<strong>一般我们读的时候是从左往右读的，但这个实现的解析的是从右往右的</strong>。<ol>
<li>根据最右的规则，决定是从idMap, classMap还是tagMap从取出<strong>最初的候选列表</strong></li>
<li>从右往左，根据一个个规则去过滤（收窄）候选列表</li>
</ol>
<ul>
<li><em>这样做的好处，能想到的是，从右往左实际上是一种自下而上的方式，可以避免自上而下需要递归的问题。</em></li>
</ul>
<ol start="3">
<li>去重和排序候选列表。去重不说，<strong>排序它使用的方法是</strong>，先找到两个node的最小的共同祖先A，设B为A下的子节点（B可能为node的祖先或者node本身），根据两个B的先后顺序，来决定node的先后顺序</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><ol>
<li>JS现在可以做跨平台的开发，虽然有些方法在浏览器中是有的，但可能别的平台没有，这时候就需要开发者去了解DOM API的实现方式。</li>
<li>假如浏览器的querySelector也是类似上述的实现方式，那么对于CSS selector的优化，可以做如下三点:<ol>
<li>优先度应该是<strong>id，class再到tag</strong>，<strong>class方面尽量使用出现频率较少的那个</strong>，<strong>尽量不要用*</strong>，因为用*相当于选择了所有的tag类型</li>
<li>关系选择器方面，<strong>尽量不要用跨层的空格selector</strong>，而要使用表示直接关系的</li>
<li><strong>selector要尽量短</strong>，因为每多一层就多一次判断</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/11/13/HTML-parser-and-querySelector/" data-id="ck64y70v40001jgu14vg1177u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/HTML/">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/parser/">parser</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/querySelector/">querySelector</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode-84-Largest-Rectangle-in-Histogram" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/11/10/Leetcode-84-Largest-Rectangle-in-Histogram/" class="article-date">
  <time datetime="2019-11-10T14:42:27.439Z" itemprop="datePublished">2019-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2019/11/10/Leetcode-84-Largest-Rectangle-in-Histogram/">Leetcode 84 Largest Rectangle in Histogram分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">题目链接</a></p>
<p>根据题解得到的思路：</p>
<ol>
<li>矩形大小等于区间内最低柱形高度乘以区间的大小</li>
<li>最大矩形等于<strong>以各柱形为最低高度时</strong>围绕它形成的最大区间的矩形大小的最大值</li>
<li>每个柱形形成的区间的<strong>左右边界</strong>为<strong>小于它高度且最靠近</strong>的矩形或者<strong>柱形数组的边界</strong></li>
</ol>
<p><strong>为了求出这些区间，题解中使用了一个栈结构</strong></p>
<p><strong>栈具有如下性质</strong></p>
<ol>
<li>每个柱形的index都会压入栈中</li>
<li>柱形A的index入栈前先把栈中高度小于A的index出栈，保证栈中index所指向的高度<strong>保持依次增大</strong>的性质。</li>
</ol>
<p><strong>换句话说栈中的上一个元素其实是当前元素的左界（因为是依次增大），</strong><br><strong>当元素出栈时（大于新加入的元素），就是右界确定的时候，左右界确定后，区间矩形大小就能求出了</strong></p>
<p><strong>参考解法</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span> = &#123; <span class="number">-1</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> heightsLength = heights.size();</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> backIndex = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; heightsLength;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          backIndex = <span class="built_in">stack</span>.back();</span><br><span class="line">          <span class="keyword">while</span>(backIndex != <span class="number">-1</span> &amp;&amp; heights[backIndex] &gt; heights[i])</span><br><span class="line">          &#123;</span><br><span class="line">            maxArea = max((i - <span class="built_in">stack</span>[<span class="built_in">stack</span>.size() - <span class="number">2</span>] - <span class="number">1</span>) * heights[backIndex], maxArea);</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">            backIndex = <span class="built_in">stack</span>.back();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">stack</span>.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        backIndex = <span class="built_in">stack</span>.back();</span><br><span class="line">        <span class="keyword">while</span>(backIndex != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          maxArea = max(maxArea, (heightsLength - <span class="built_in">stack</span>[<span class="built_in">stack</span>.size() - <span class="number">2</span>] - <span class="number">1</span>) * heights[backIndex]);</span><br><span class="line">          <span class="built_in">stack</span>.pop_back();</span><br><span class="line">          backIndex = <span class="built_in">stack</span>.back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/11/10/Leetcode-84-Largest-Rectangle-in-Histogram/" data-id="ck64y70va0003jgu1wvtsd3tk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/algorithm/">algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/stack/">stack</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-web-front-end-knowledge-memo(Algorithm)-ep1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/11/04/web-front-end-knowledge-memo(Algorithm)-ep1/" class="article-date">
  <time datetime="2019-11-04T14:32:15.668Z" itemprop="datePublished">2019-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2019/11/04/web-front-end-knowledge-memo(Algorithm)-ep1/">web前端知识学习笔记-算法篇(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="下面的内容为排序算法逻辑的摘要，主要目的是方便本人记忆"><a href="#下面的内容为排序算法逻辑的摘要，主要目的是方便本人记忆" class="headerlink" title="下面的内容为排序算法逻辑的摘要，主要目的是方便本人记忆"></a>下面的内容为排序算法逻辑的摘要，主要目的是方便本人记忆</h2><p><strong>1. 归并排序（merge sort）</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sort(originalArray) &#123;</span><br><span class="line">     <span class="comment">// 当array的规模小于等于1时结束分治</span></span><br><span class="line">     <span class="keyword">if</span> (originalArray.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> originalArray;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从中间分开左右两个子数组</span></span><br><span class="line">     <span class="keyword">const</span> leftArray = originalArray.slice(<span class="number">0</span>, middleIndex);</span><br><span class="line">     <span class="keyword">const</span> rightArray = originalArray.slice(middleIndex, originalArray.length);</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">const</span> leftSortedArray = sort(leftArray);</span><br><span class="line">     <span class="keyword">const</span> rightSortedArray = sort(rightArray);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 每次从左右两个已排好序的数组选取出一个最小的元素，加入结果数组</span></span><br><span class="line">     <span class="keyword">while</span> (leftArray.length &amp;&amp; rightArray.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (leftArray[<span class="number">0</span>] &lt; rightArray[<span class="number">0</span>]) &#123;</span><br><span class="line">        minimumElement = leftArray.shift();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        minimumElement = rightArray.shift();</span><br><span class="line">      &#125;</span><br><span class="line">      sortedArray.push(minimumElement);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 快速排序（quick sort）</strong></p>
<ol>
<li><p>非原地</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sort(array) &#123;</span><br><span class="line">     <span class="keyword">const</span> pivotElement = array.shift();</span><br><span class="line">     <span class="comment">// 根据与基准的大小关系，把元素归入到左，中，右三个子数组</span></span><br><span class="line">     <span class="keyword">while</span> (array.length) &#123;</span><br><span class="line">          <span class="keyword">const</span> currentElement = array.shift();</span><br><span class="line">          <span class="keyword">if</span> ((currentElement === pivotElement)) &#123;</span><br><span class="line">          centerArray.push(currentElement);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentElement &lt; pivotElement)) &#123;</span><br><span class="line">          leftArray.push(currentElement);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          rightArray.push(currentElement);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 左右两数组在其内部进行排序</span></span><br><span class="line">     <span class="keyword">const</span> leftArraySorted = sort(leftArray);</span><br><span class="line">     <span class="keyword">const</span> rightArraySorted = sort(rightArray);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 合并左中右三个子数组</span></span><br><span class="line">     leftArraySorted.concat(centerArray, rightArraySorted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原地</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sort(array, inputLowIndex = <span class="number">0</span>, inputHighIndex = array.length - <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (inputLowIndex &lt; inputHighIndex) &#123;</span><br><span class="line">      <span class="keyword">let</span> partitionIndex = inputLowIndex;</span><br><span class="line">      <span class="keyword">const</span> pivot = array[highIndex];</span><br><span class="line">      <span class="comment">// 把小于最右元素的元素与partitionIndex指向的元素交换位置</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> currentIndex = lowIndex; currentIndex &lt; highIndex; currentIndex += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[currentIndex] &lt; pivot) &#123;</span><br><span class="line">          swap(partitionIndex, currentIndex);</span><br><span class="line">          partitionIndex += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(partitionIndex, highIndex);</span><br><span class="line">      <span class="comment">// 以partitionIndex作为分界点，分开左右范围进行排序</span></span><br><span class="line">      sort(array, inputLowIndex, partitionIndex - <span class="number">1</span>);</span><br><span class="line">      sort(array, partitionIndex + <span class="number">1</span>, inputHighIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>3. 堆排序</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建最小堆</span></span><br><span class="line"><span class="comment">// 每次取出堆顶元素，然后把堆中最后的元素放到堆顶，根据规则，重新建立最小堆</span></span><br><span class="line">leftChildIndex(parentIndex) &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="number">2</span> * parentIndex) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">rightChildIndex(parentIndex) &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="number">2</span> * parentIndex) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">parentIndex(childIndex) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Math</span>.floor((childIndex - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最后一个元素开始确认父元素是否小于子元素</span></span><br><span class="line">heapifyUp() &#123;</span><br><span class="line">     <span class="keyword">let</span> currentIndex = heapContainer.length - <span class="number">1</span></span><br><span class="line">     <span class="keyword">while</span>(hasParent(currentIndex) &amp;&amp; heapContainer[parentIndex] &gt; heapContainer[currentIndex]) &#123;</span><br><span class="line">          swap(heapContainer, currentIndex, parentIndex);</span><br><span class="line">          currentIndex = parentIndex</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第一个元素开始确认父元素是否小于子元素</span></span><br><span class="line">heapifyDown() &#123;</span><br><span class="line">    <span class="keyword">let</span> currentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> nextIndex = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.hasLeftChild(currentIndex)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="keyword">this</span>.hasRightChild(currentIndex)</span><br><span class="line">        &amp;&amp; rightChild &gt; leftChild)</span><br><span class="line">      ) &#123;</span><br><span class="line">        nextIndex = getRightChildIndex(currentIndex);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextIndex = getLeftChildIndex(currentIndex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (heapContainer[currentIndex] &lt; heapContainer[nextIndex]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      swap(heapContainer, currentIndex, nextIndex);</span><br><span class="line">      currentIndex = nextIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(item) &#123;</span><br><span class="line">     heapContainer.push(item)</span><br><span class="line">     heapifyUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最小堆中取出堆顶，就是poll这个操作</span></span><br><span class="line">poll() &#123;</span><br><span class="line">     <span class="keyword">const</span> item = heapContainer[<span class="number">0</span>]</span><br><span class="line">     heapContainer[<span class="number">0</span>] = heapContainer.pop()</span><br><span class="line">     heapifyDown()</span><br><span class="line">     <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>奇怪的是根据下面代码来源的资料，heap sort的空间复杂度是O(1)，可是上面的实现方式是需要创建两个数组的，</em></strong><br><strong><em>按上面的实现应该是O(n)才对。后面经过搜索，得知heap sort实际上是可以原地实现的。实现如下：</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">add() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">    <span class="comment">// 从i到0构建**最大堆**</span></span><br><span class="line">    heapifyUp(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i++) &#123;</span><br><span class="line">    <span class="comment">// 让i与0交换</span></span><br><span class="line">    swap(i, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 调整堆至i - 1处，交换以后的i排除在heapifyDown的操作范围内</span></span><br><span class="line">    heapifyDown(i - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意上面的是最大堆，因为这样取出的时候可以把堆顶的这个最大值与末尾的元素进行交换</span></span><br><span class="line"><span class="comment">// 最后结果能够从小到大排列</span></span><br><span class="line"><span class="comment">// 上面写的都是伪代码，力求把逻辑简洁地表述出来</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/trekhleb/javascript-algorithms" target="_blank" rel="noopener">代码来源</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/11/04/web-front-end-knowledge-memo(Algorithm)-ep1/" data-id="ck64y70vw000gjgu13w0hinsx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/algorithm/">algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/interview/">interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/sorting/">sorting</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/study-memo/page/2/">2</a><a class="page-number" href="/study-memo/page/3/">3</a><a class="extend next" rel="next" href="/study-memo/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/AST/">AST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/CLI/">CLI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/Clang/">Clang++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/IIFE/">IIFE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/Needleman-Wunsch/">Needleman-Wunsch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/SSR/">SSR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/Yox/">Yox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/algorithm/">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/bin-pack/">bin-pack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/compile/">compile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/diff/">diff</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/dll/">dll</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/eventloop/">eventloop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/expression/">expression</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/externals/">externals</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/framework/">framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/hoisting/">hoisting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/hot-reload/">hot-reload</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/interview/">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/location指令/">location指令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/meta/">meta</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/mvvm/">mvvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/parser/">parser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/performance/">performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/plugin/">plugin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/promise/">promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/querySelector/">querySelector</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/redux/">redux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/setTimeout/">setTimeout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/sorting/">sorting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/sprite/">sprite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/stack/">stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/store/">store</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/stream/">stream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/submodule/">submodule</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/template/">template</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/temporary-variable/">temporary variable</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/viewport/">viewport</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/watcher/">watcher</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/websocket/">websocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/whistle/">whistle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/windows/">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/立即执行函数/">立即执行函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/语义化/">语义化</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/study-memo/tags/AST/" style="font-size: 10px;">AST</a> <a href="/study-memo/tags/C/" style="font-size: 10px;">C++</a> <a href="/study-memo/tags/CLI/" style="font-size: 10px;">CLI</a> <a href="/study-memo/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/study-memo/tags/Clang/" style="font-size: 10px;">Clang++</a> <a href="/study-memo/tags/HTML/" style="font-size: 15px;">HTML</a> <a href="/study-memo/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/study-memo/tags/IIFE/" style="font-size: 10px;">IIFE</a> <a href="/study-memo/tags/Needleman-Wunsch/" style="font-size: 10px;">Needleman-Wunsch</a> <a href="/study-memo/tags/SSR/" style="font-size: 10px;">SSR</a> <a href="/study-memo/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/study-memo/tags/Yox/" style="font-size: 10px;">Yox</a> <a href="/study-memo/tags/algorithm/" style="font-size: 17.5px;">algorithm</a> <a href="/study-memo/tags/bin-pack/" style="font-size: 10px;">bin-pack</a> <a href="/study-memo/tags/compile/" style="font-size: 10px;">compile</a> <a href="/study-memo/tags/diff/" style="font-size: 10px;">diff</a> <a href="/study-memo/tags/dll/" style="font-size: 10px;">dll</a> <a href="/study-memo/tags/eventloop/" style="font-size: 10px;">eventloop</a> <a href="/study-memo/tags/expression/" style="font-size: 10px;">expression</a> <a href="/study-memo/tags/externals/" style="font-size: 10px;">externals</a> <a href="/study-memo/tags/framework/" style="font-size: 10px;">framework</a> <a href="/study-memo/tags/git/" style="font-size: 12.5px;">git</a> <a href="/study-memo/tags/hoisting/" style="font-size: 10px;">hoisting</a> <a href="/study-memo/tags/hot-reload/" style="font-size: 10px;">hot-reload</a> <a href="/study-memo/tags/interview/" style="font-size: 20px;">interview</a> <a href="/study-memo/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/study-memo/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/study-memo/tags/location指令/" style="font-size: 10px;">location指令</a> <a href="/study-memo/tags/meta/" style="font-size: 10px;">meta</a> <a href="/study-memo/tags/mvvm/" style="font-size: 10px;">mvvm</a> <a href="/study-memo/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/study-memo/tags/parser/" style="font-size: 10px;">parser</a> <a href="/study-memo/tags/performance/" style="font-size: 12.5px;">performance</a> <a href="/study-memo/tags/plugin/" style="font-size: 10px;">plugin</a> <a href="/study-memo/tags/promise/" style="font-size: 10px;">promise</a> <a href="/study-memo/tags/querySelector/" style="font-size: 10px;">querySelector</a> <a href="/study-memo/tags/react/" style="font-size: 10px;">react</a> <a href="/study-memo/tags/redux/" style="font-size: 10px;">redux</a> <a href="/study-memo/tags/setTimeout/" style="font-size: 10px;">setTimeout</a> <a href="/study-memo/tags/sorting/" style="font-size: 10px;">sorting</a> <a href="/study-memo/tags/sprite/" style="font-size: 10px;">sprite</a> <a href="/study-memo/tags/stack/" style="font-size: 10px;">stack</a> <a href="/study-memo/tags/store/" style="font-size: 10px;">store</a> <a href="/study-memo/tags/stream/" style="font-size: 10px;">stream</a> <a href="/study-memo/tags/submodule/" style="font-size: 10px;">submodule</a> <a href="/study-memo/tags/template/" style="font-size: 12.5px;">template</a> <a href="/study-memo/tags/temporary-variable/" style="font-size: 10px;">temporary variable</a> <a href="/study-memo/tags/viewport/" style="font-size: 10px;">viewport</a> <a href="/study-memo/tags/vue/" style="font-size: 17.5px;">vue</a> <a href="/study-memo/tags/watcher/" style="font-size: 10px;">watcher</a> <a href="/study-memo/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/study-memo/tags/websocket/" style="font-size: 10px;">websocket</a> <a href="/study-memo/tags/whistle/" style="font-size: 10px;">whistle</a> <a href="/study-memo/tags/windows/" style="font-size: 10px;">windows</a> <a href="/study-memo/tags/立即执行函数/" style="font-size: 10px;">立即执行函数</a> <a href="/study-memo/tags/语义化/" style="font-size: 10px;">语义化</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/study-memo/2020/08/16/misunderstandings-of-nginx-location-config/">nginx location指令配置的误解</a>
          </li>
        
          <li>
            <a href="/study-memo/2020/04/19/optimization-techniques-for-better-performance-of-vue-app/">Vue应用性能调优技巧</a>
          </li>
        
          <li>
            <a href="/study-memo/2020/03/18/experience-of-using-git-submodule/">git submodule的使用经验</a>
          </li>
        
          <li>
            <a href="/study-memo/2020/02/23/yox-research-template-expression-episode/">Yox框架研究（1）—模板表达式编译篇</a>
          </li>
        
          <li>
            <a href="/study-memo/2020/02/01/vue-ssr-demo-following-official-guide/">按照官方指南实践vue SSR</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Sociosarbis<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/study-memo/" class="mobile-nav-link">Home</a>
  
    <a href="/study-memo/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/study-memo/fancybox/jquery.fancybox.css">
  <script src="/study-memo/fancybox/jquery.fancybox.pack.js"></script>


<script src="/study-memo/js/script.js"></script>



  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>a house in the woods</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="a house in the woods">
<meta property="og:url" content="https://sociosarbis.github.io/study-memo/index.html">
<meta property="og:site_name" content="a house in the woods">
<meta property="og:locale" content="zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="a house in the woods">
  
    <link rel="alternate" href="/study-memo/atom.xml" title="a house in the woods" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/study-memo/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/study-memo/" id="logo">a house in the woods</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/study-memo/">Home</a>
        
          <a class="main-nav-link" href="/study-memo/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/study-memo/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://sociosarbis.github.io/study-memo"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-from-whistle-hot-reload-plugin-develoment-to-websocket-mechanism" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/12/27/from-whistle-hot-reload-plugin-develoment-to-websocket-mechanism/" class="article-date">
  <time datetime="2019-12-26T16:36:40.565Z" itemprop="datePublished">2019-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2019/12/27/from-whistle-hot-reload-plugin-develoment-to-websocket-mechanism/">从whistle热重载插件到websocket工作原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>工作上有些需求是需要去改后端渲染的文件的，但是由于不是通过webpack开发，没有修改完立刻更新页面的功能，所以显得不是太方便。要实时更新页面可以通过热重载或热更新，热重载比较简单，其实就是页面自动reload，热更新则需要重新打包已更改的文件，然后通过websoket发送新的补丁，完成更改。 </li>
</ul>
<h3 id="需要实现的功能"><a href="#需要实现的功能" class="headerlink" title="需要实现的功能"></a>需要实现的功能</h3><ul>
<li>先不谈复杂的热更新，对于后端渲染的这类比较简单的页面，热重载已经能够很好地方便我们的开发了。</li>
<li>要做热重载，需要做以下两个功能：<ol>
<li>监听文件的更改</li>
<li>通知页面进行reload</li>
</ol>
</li>
<li>第一点比较简单，可以使用<a href=""><code>fs.watch</code></a>或者跨平台的库<a href="https://www.npmjs.com/package/chokidar" target="_blank" rel="noopener"><code>chokidar</code></a>，都可以进行对文件更改的监听。</li>
<li>第二点对页面进行通知，我们平时用webpack开发的时候自然会发现页面会打开一个websocket的连接，而这个连接就是起服务器与页面客户端间通信的作用。</li>
</ul>
<h3 id="websocket的工作流程"><a href="#websocket的工作流程" class="headerlink" title="websocket的工作流程"></a>websocket的工作流程</h3><ul>
<li>下一步就是怎么创建一个websokcet的连接的问题，分为两个部分，server和client</li>
<li>client：<ul>
<li>对于比较简单的应用，例如这种通知更新的，可以简单地使用浏览器提供的<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank" rel="noopener"><code>Websocket</code></a>的api</li>
</ul>
</li>
<li><p>sever：</p>
<ul>
<li>首先node没有提供直接的api，可以用第三方库或者自己实现。对于第三方库，比较著名的有<code>socket.io</code>，不过需要在页面中使用客户端对应的库，所以不作考虑。而留意到webpack-dev-server用到的库是<code>sockjs-node</code>， 使用浏览器的api就可完成连接，所以这里就选用该库。</li>
<li><p>先来看一下简单用例①:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> sockjs = <span class="built_in">require</span>(<span class="string">'sockjs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> echo = sockjs.createServer(&#123; <span class="attr">prefix</span>:<span class="string">'/echo'</span> &#125;);</span><br><span class="line">echo.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">conn</span>) </span>&#123;</span><br><span class="line">conn.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    conn.write(message);</span><br><span class="line">&#125;);</span><br><span class="line">conn.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line">echo.attach(server);</span><br><span class="line">server.listen(<span class="number">9999</span>, <span class="string">'0.0.0.0'</span>);</span><br></pre></td></tr></table></figure>
<p>如果了解过node.js，<code>http.createServer</code>的作用是创建一个http的服务器，那为什么又有一个类似的<code>sockjs.createServer</code>的方法，难道真的是创建多一个服务器吗？<br>带着这个疑问，翻看源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">events</span>.<span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(user_options) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.options = <span class="built_in">Object</span>.assign(</span><br><span class="line">        &#123;</span><br><span class="line">            prefix: <span class="string">''</span>,</span><br><span class="line">            transports: [</span><br><span class="line">            <span class="string">'eventsource'</span>,</span><br><span class="line">            <span class="string">'htmlfile'</span>,</span><br><span class="line">            <span class="string">'jsonp-polling'</span>,</span><br><span class="line">            <span class="string">'websocket'</span>,</span><br><span class="line">            <span class="string">'websocket-raw'</span>,</span><br><span class="line">            <span class="string">'xhr-polling'</span>,</span><br><span class="line">            <span class="string">'xhr-streaming'</span></span><br><span class="line">            ],</span><br><span class="line">            response_limit: <span class="number">128</span> * <span class="number">1024</span>,</span><br><span class="line">            faye_server_options: <span class="literal">null</span>,</span><br><span class="line">            jsessionid: <span class="literal">false</span>,</span><br><span class="line">            heartbeat_delay: <span class="number">25000</span>,</span><br><span class="line">            disconnect_delay: <span class="number">5000</span>,</span><br><span class="line">            log() &#123;&#125;,</span><br><span class="line">            sockjs_url: <span class="string">'https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        user_options</span><br><span class="line">        );</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>.handler = webjs.generateHandler(<span class="keyword">this</span>, listener.generateDispatcher(<span class="keyword">this</span>.options));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它并没有做任何与连接相关的工作。然后再看到用例①中对于sockjs创建的这个<strong>“server”</strong> ，还有一步是<code>echo.attach(server)</code>，看来这里才是<strong>“sockjs sever”</strong>工作的入口。源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">attach(server) &#123;</span><br><span class="line">    <span class="keyword">this</span>._rlisteners = <span class="keyword">this</span>._installListener(server, <span class="string">'request'</span>);</span><br><span class="line">    <span class="keyword">this</span>._ulisteners = <span class="keyword">this</span>._installListener(server, <span class="string">'upgrade'</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>原来是对<strong>http server</strong>的<strong>request</strong>和<strong>upgrade</strong>事件做监听。<br><strong>request</strong>是收到http请求时触发的，那<strong>upgrade</strong>呢？</p>
<h4 id="根据node的文档所述："><a href="#根据node的文档所述：" class="headerlink" title="根据node的文档所述："></a>根据node的文档所述：</h4><blockquote>
<p>Emitted each time a server responds to a <strong>request with an upgrade</strong>. </p>
</blockquote>
<p>这里的<strong>request with an upgrade</strong>，通过后面的example，粗浅地可以认为是<strong>Connection</strong> header为<code>&#39;Upgrade&#39;</code>，并且还有一个<code>Upgrade</code>header的<strong>request</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    ...</span><br><span class="line">    headers: &#123;</span><br><span class="line">    <span class="string">'Connection'</span>: <span class="string">'Upgrade'</span>,</span><br><span class="line">    <span class="string">'Upgrade'</span>: <span class="string">'websocket'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> req = http.request(options);</span><br></pre></td></tr></table></figure>
</li>
<li><p>request事件的callback参数为<strong>request和response</strong>，而upgrade事件则是<strong>request，socket和head</strong>。第二个参数由<strong>response变为socket</strong>，而这个socket参数就是client和server间的TCP连接，而<strong>websocket</strong>就是对这个<strong>TCP连接的socket对象</strong>进行操作，根据<strong>websocket</strong>协议的规则，对<strong>socket</strong>对象中通信的数据进行解析读入和封装用户的消息进行写入。</p>
</li>
<li><p>顺带一提，对于要upgrade为websocket的请求，服务端也会写入符合http规则的响应报文（而这个过程称作建立websocket连接的握手），并且不会调用<code>response.end或者说socket.end</code>去结束服务端和客户端的连接。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.write(<span class="string">'HTTP/1.1 101 Web Socket Protocol Handshake\r\n'</span> +</span><br><span class="line">    <span class="string">'Upgrade: WebSocket\r\n'</span> +</span><br><span class="line">    <span class="string">'Connection: Upgrade\r\n'</span> +</span><br><span class="line">    <span class="string">'\r\n'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>ps：</strong>建立websocket的request还会有<code>sec-websocket-version</code>和<code>sec-websocket-key</code>等headers，而response还会有<code>sec-webSocket-accept</code>等headers，由于本文主旨在于建立websocket的通信流程的概念，所以具体的协议标准等知识，可自行search。</p>
</li>
<li><p>建立了websocket的连接，下面就是要知道是怎么从socket收到消息和写消息到socket中。这两个步骤对应于这两行来自<strong>faye-websocket\lib\faye\websocket\api.js</strong>的代码(<strong>faye-websocket</strong>是<strong>sockjs-node</strong>的依赖库)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._stream.pipe(<span class="keyword">this</span>._driver.io);</span><br><span class="line"><span class="keyword">this</span>._driver.io.pipe(<span class="keyword">this</span>._stream);</span><br></pre></td></tr></table></figure>
<p><code>this._stream</code>就是TCP的<code>socket</code>（也是流对象），而<code>this._driver.io</code>是一个双工(Duplex, 意为可读可写)的流。<br><strong>ps:</strong>流就是nodejs的Stream类。</p>
</li>
<li>之前我看到pipe这个方法，对他的机制有点摸不着头脑，不知道他是在什么时候才会把数据传到<strong>可写流（Stream.Writable）</strong>中。要解决这个疑问，只需要看到这一步，就知道触发<strong>可读流(Stream.Readable)</strong>的<code>data</code>事件时，就会把数据写到可写流中。而data事件的其中一个触发时机，就在Readable的read方法中。而pipe方法在最后，会通过resume方法，让流进入<strong>flowing</strong> mode，这个mode简单来讲就是假如Readable的<strong>Internal buffer(内部缓存)</strong>，就会通过循环不断地调用read。<h5 id="最后一个疑问他内部缓存地数据又是从哪里来的呢？"><a href="#最后一个疑问他内部缓存地数据又是从哪里来的呢？" class="headerlink" title="最后一个疑问他内部缓存地数据又是从哪里来的呢？"></a>最后一个疑问他内部缓存地数据又是从哪里来的呢？</h5>答案是在<code>read</code>方法中，会调用<code>_read</code>方法。<code>_read</code>方法的作用是调用<code>Readable.push</code>方法，把数据放到<strong>Internal buffer</strong>里。可能这也是为什么在继承或者实现Readable的时候，需要去实现一个<code>_read</code>方法来获取自定义数据。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/nodejs/node/blob/master/lib/_stream_readable.js</span></span><br><span class="line">src.on(<span class="string">'data'</span>, ondata);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> ret = dest.write(chunk);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!state.flowing) &#123;</span><br><span class="line">    debug(<span class="string">'pipe resume'</span>);</span><br><span class="line">    src.resume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dest;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="websocket的内容就介绍到这里，下面是要讲的是完成热重载需求的whistle插件的开发。"><a href="#websocket的内容就介绍到这里，下面是要讲的是完成热重载需求的whistle插件的开发。" class="headerlink" title="websocket的内容就介绍到这里，下面是要讲的是完成热重载需求的whistle插件的开发。"></a>websocket的内容就介绍到这里，下面是要讲的是完成热重载需求的whistle插件的开发。</h4><p>为了更好地理解下面的内容，可先阅读whistle文档中<a href="https://wproxy.org/whistle/plugins.html" target="_blank" rel="noopener"><strong>插件开发</strong></a>的部分。</p>
<p>如下是我在看过文档，github上的demo和whistle的源码后的几点所得。</p>
<ol>
<li>whistle的插件实际上就是让插件export一个接收<strong>server对象的函数</strong>, 然后自己编写对<strong>server对象</strong>事件响应的callback，事件主要是request和connect，request就是普通的http请求，connect可以是websocket或者tunnel请求(<em>ps:没了解过tunnel请求</em>)</li>
<li><p><strong>每个插件都会创建一个监听本地新端口的入口server，其主要的作用是把请求分发给它其下的子server，而这些server虽然都是真的http server，但它们不会监听端口，在请求的不同阶段，入口server会把请求分发到对应的子server</strong>，子server有如下这些：</p>
<ol>
<li>uiServer</li>
<li>reqRead</li>
<li>reqWrite</li>
<li>resRead</li>
<li>resRulesServer</li>
<li>resStatsServer</li>
<li>resWrite</li>
<li>rulesServer</li>
<li>server</li>
<li>statsServer</li>
<li>tunnelReqRead</li>
<li>tunnelReqWrite</li>
<li>tunnelResRead</li>
<li>tunnelResWrite</li>
<li>tunnelRulesServer</li>
<li>wsReqRead</li>
<li>wsReqWrite</li>
<li>wsResRead</li>
<li><p>wsResWrite<br>但问题是具体需要怎么响应对这些server的请求事件，文档里没有说明。只能在提供的demo中找到，某些server具体需要response什么东西。<br>例如<code>&#39;rulesServer&#39;</code>结尾的server，需要response如下的JSON数据来动态地去添加whistle的规则。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    rules: <span class="string">`<span class="subst">$&#123;req.headers.host&#125;</span>/sw-register.js file://&#123;sw-register&#125;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;req.headers.host&#125;</span>/sw.js file://&#123;sw-content&#125;`</span>,</span><br><span class="line">    values: &#123;</span><br><span class="line">        <span class="string">'sw-register'</span>: registerContent,</span><br><span class="line">        <span class="string">'sw-content'</span>: content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">null</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p><strong>rules</strong>是whisle规则的文本，<strong>values</strong>则是用于替换规则中的变量。<br>所以如果我们需要给我页面注入，websocket client的代码的话就在ruleServer中<code>response.end(rules)</code>就可以实现了。</p>
</li>
</ol>
</li>
<li>规则的值，如<code>www.ifeng.com method://post</code>中的<code>post</code>，可通过<code>req.originalReq.ruleValue</code>获取。</li>
<li>server当中有两个比较特别的，一个是<strong>uiServer</strong>，需要写一个完整的有前端页面的web应用，让用户修改插件的配置，给其他server去获取使用。另外一个是上面<strong>No.9的”server”</strong>，这个相当于一个代理的服务器，他的response会成为最后whistle传回来的那个response，其他的如ruleServer，就只是像上面说的只是通过resposne来增加一些临时的新规则。</li>
<li>*Read,*Write这两种结尾的server，本人到目前为止还不清楚到底要怎么用。</li>
</ol>
<h3 id="下面是这个插件简单的实现代码："><a href="#下面是这个插件简单的实现代码：" class="headerlink" title="下面是这个插件简单的实现代码："></a>下面是这个插件简单的实现代码：</h3><p><a href="https://github.com/Sociosarbis/whistle.hot-reload-plugin" target="_blank" rel="noopener">whistle.hot-reload-plugin</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>虽然这个功能很简单，但是它涉及到的知识还是很多的，而且还没有完全弄明白， 后面继续学习。</li>
<li>whistle的代码目前对我来说还是比较复杂的，涉及到协议的不同规则，请求转发， stream pipe等web后端的知识。 </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/12/27/from-whistle-hot-reload-plugin-develoment-to-websocket-mechanism/" data-id="ck4myvetj0000agu150pcg0fz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/hot-reload/">hot-reload</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/plugin/">plugin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/stream/">stream</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/websocket/">websocket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/whistle/">whistle</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HTML-parser-and-querySelector" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/11/13/HTML-parser-and-querySelector/" class="article-date">
  <time datetime="2019-11-13T08:49:36.794Z" itemprop="datePublished">2019-11-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2019/11/13/HTML-parser-and-querySelector/">HTML parser和querySelector实现分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>最近在学习React Native的开发，把web端的网站转成app，由于部分api的缺失，需要从web的HTML里提取信息，那么就需要一个解析HTML的工具。</li>
<li>cheerio就是其中一个有名的库，但遗憾的是cheerio本身不支持在React Native环境运行。</li>
<li>记得之前看过微信团队的一个开源项目<a href="https://github.com/wechat-miniprogram/kbone" target="_blank" rel="noopener">kbone</a>是通过在小程序中模拟浏览器环境让面向web端开发的应用也能运行在小程序中。里面就包含了<strong>HTML parser</strong>和<strong>querySelector</strong>的实现，这两个的实现主要是<br>参考了<a href="https://johnresig.com/files/htmlparser.js" target="_blank" rel="noopener">HTMLParser</a>和<a href="https://github.com/jquery/sizzle/tree/master" target="_blank" rel="noopener">Jquery的sizzle</a>。</li>
<li>具体实现可以到上面的仓库查看相关代码，下面介绍实现的主要逻辑</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><strong>HTML parser</strong><ol>
<li>建立一个栈stack </li>
<li>抛开正则表达式不讲，最重要的逻辑是把遇到的<strong>开始标签(opening tag)</strong>时，会做如下操作：<ol>
<li>如果栈不为空，就<strong>把新的标签加到栈顶的children数组</strong>中</li>
<li>把它<strong>存到stack</strong></li>
</ol>
</li>
<li>当遇到<strong>结束标签(closing tag)</strong>时，把stack中相同类型的标签压出</li>
</ol>
</li>
<li><strong>querySelector</strong><ol>
<li>初始的时候，遍历parser解析出的HTML tree，把node的id，class和tag分别加入到<strong>idMap</strong>, <strong>classMap</strong>，<strong>tagMap</strong>中</li>
<li>selector的解析，<strong>一般我们读的时候是从左往右读的，但这个实现的解析的是从右往右的</strong>。<ol>
<li>根据最右的规则，决定是从idMap, classMap还是tagMap从取出<strong>最初的候选列表</strong></li>
<li>从右往左，根据一个个规则去过滤（收窄）候选列表</li>
</ol>
<ul>
<li><em>这样做的好处，能想到的是，从右往左实际上是一种自下而上的方式，可以避免自上而下需要递归的问题。</em></li>
</ul>
<ol start="3">
<li>去重和排序候选列表。去重不说，<strong>排序它使用的方法是</strong>，先找到两个node的最小的共同祖先A，设B为A下的子节点（B可能为node的祖先或者node本身），根据两个B的先后顺序，来决定node的先后顺序</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><ol>
<li>JS现在可以做跨平台的开发，虽然有些方法在浏览器中是有的，但可能别的平台没有，这时候就需要开发者去了解DOM API的实现方式。</li>
<li>假如浏览器的querySelector也是类似上述的实现方式，那么对于CSS selector的优化，可以做如下三点:<ol>
<li>优先度应该是<strong>id，class再到tag</strong>，<strong>class方面尽量使用出现频率较少的那个</strong>，<strong>尽量不要用*</strong>，因为用*相当于选择了所有的tag类型</li>
<li>关系选择器方面，<strong>尽量不要用跨层的空格selector</strong>，而要使用表示直接关系的</li>
<li><strong>selector要尽量短</strong>，因为每多一层就多一次判断</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/11/13/HTML-parser-and-querySelector/" data-id="ck2x57l6200005su1oi54j1jj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/HTML/">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/parser/">parser</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/querySelector/">querySelector</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode-84-Largest-Rectangle-in-Histogram" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/11/10/Leetcode-84-Largest-Rectangle-in-Histogram/" class="article-date">
  <time datetime="2019-11-10T14:42:27.439Z" itemprop="datePublished">2019-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2019/11/10/Leetcode-84-Largest-Rectangle-in-Histogram/">Leetcode 84 Largest Rectangle in Histogram分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">题目链接</a></p>
<p>根据题解得到的思路：</p>
<ol>
<li>矩形大小等于区间内最低柱形高度乘以区间的大小</li>
<li>最大矩形等于<strong>以各柱形为最低高度时</strong>围绕它形成的最大区间的矩形大小的最大值</li>
<li>每个柱形形成的区间的<strong>左右边界</strong>为<strong>小于它高度且最靠近</strong>的矩形或者<strong>柱形数组的边界</strong></li>
</ol>
<p><strong>为了求出这些区间，题解中使用了一个栈结构</strong></p>
<p><strong>栈具有如下性质</strong></p>
<ol>
<li>每个柱形的index都会压入栈中</li>
<li>柱形A的index入栈前先把栈中高度小于A的index出栈，保证栈中index所指向的高度<strong>保持依次增大</strong>的性质。</li>
</ol>
<p><strong>换句话说栈中的上一个元素其实是当前元素的左界（因为是依次增大），</strong><br><strong>当元素出栈时（大于新加入的元素），就是右界确定的时候，左右界确定后，区间矩形大小就能求出了</strong></p>
<p><strong>参考解法</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span> = &#123; <span class="number">-1</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> heightsLength = heights.size();</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> backIndex = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; heightsLength;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          backIndex = <span class="built_in">stack</span>.back();</span><br><span class="line">          <span class="keyword">while</span>(backIndex != <span class="number">-1</span> &amp;&amp; heights[backIndex] &gt; heights[i])</span><br><span class="line">          &#123;</span><br><span class="line">            maxArea = max((i - <span class="built_in">stack</span>[<span class="built_in">stack</span>.size() - <span class="number">2</span>] - <span class="number">1</span>) * heights[backIndex], maxArea);</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">            backIndex = <span class="built_in">stack</span>.back();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">stack</span>.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        backIndex = <span class="built_in">stack</span>.back();</span><br><span class="line">        <span class="keyword">while</span>(backIndex != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          maxArea = max(maxArea, (heightsLength - <span class="built_in">stack</span>[<span class="built_in">stack</span>.size() - <span class="number">2</span>] - <span class="number">1</span>) * heights[backIndex]);</span><br><span class="line">          <span class="built_in">stack</span>.pop_back();</span><br><span class="line">          backIndex = <span class="built_in">stack</span>.back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/11/10/Leetcode-84-Largest-Rectangle-in-Histogram/" data-id="ck2t55gpg0000tku1hwyno1bg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/algorithm/">algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/stack/">stack</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-web-front-end-knowledge-memo(Algorithm)-ep1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/11/04/web-front-end-knowledge-memo(Algorithm)-ep1/" class="article-date">
  <time datetime="2019-11-04T14:32:15.668Z" itemprop="datePublished">2019-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2019/11/04/web-front-end-knowledge-memo(Algorithm)-ep1/">web前端知识学习笔记-算法篇(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="下面的内容为排序算法逻辑的摘要，主要目的是方便本人记忆"><a href="#下面的内容为排序算法逻辑的摘要，主要目的是方便本人记忆" class="headerlink" title="下面的内容为排序算法逻辑的摘要，主要目的是方便本人记忆"></a>下面的内容为排序算法逻辑的摘要，主要目的是方便本人记忆</h2><p><strong>1. 归并排序（merge sort）</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sort(originalArray) &#123;</span><br><span class="line">     <span class="comment">// 当array的规模小于等于1时结束分治</span></span><br><span class="line">     <span class="keyword">if</span> (originalArray.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> originalArray;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从中间分开左右两个子数组</span></span><br><span class="line">     <span class="keyword">const</span> leftArray = originalArray.slice(<span class="number">0</span>, middleIndex);</span><br><span class="line">     <span class="keyword">const</span> rightArray = originalArray.slice(middleIndex, originalArray.length);</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">const</span> leftSortedArray = sort(leftArray);</span><br><span class="line">     <span class="keyword">const</span> rightSortedArray = sort(rightArray);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 每次从左右两个已排好序的数组选取出一个最小的元素，加入结果数组</span></span><br><span class="line">     <span class="keyword">while</span> (leftArray.length &amp;&amp; rightArray.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (leftArray[<span class="number">0</span>] &lt; rightArray[<span class="number">0</span>]) &#123;</span><br><span class="line">        minimumElement = leftArray.shift();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        minimumElement = rightArray.shift();</span><br><span class="line">      &#125;</span><br><span class="line">      sortedArray.push(minimumElement);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 快速排序（quick sort）</strong></p>
<ol>
<li><p>非原地</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sort(array) &#123;</span><br><span class="line">     <span class="keyword">const</span> pivotElement = array.shift();</span><br><span class="line">     <span class="comment">// 根据与基准的大小关系，把元素归入到左，中，右三个子数组</span></span><br><span class="line">     <span class="keyword">while</span> (array.length) &#123;</span><br><span class="line">          <span class="keyword">const</span> currentElement = array.shift();</span><br><span class="line">          <span class="keyword">if</span> ((currentElement === pivotElement)) &#123;</span><br><span class="line">          centerArray.push(currentElement);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentElement &lt; pivotElement)) &#123;</span><br><span class="line">          leftArray.push(currentElement);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          rightArray.push(currentElement);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 左右两数组在其内部进行排序</span></span><br><span class="line">     <span class="keyword">const</span> leftArraySorted = sort(leftArray);</span><br><span class="line">     <span class="keyword">const</span> rightArraySorted = sort(rightArray);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 合并左中右三个子数组</span></span><br><span class="line">     leftArraySorted.concat(centerArray, rightArraySorted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原地</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sort(array, inputLowIndex = <span class="number">0</span>, inputHighIndex = array.length - <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (inputLowIndex &lt; inputHighIndex) &#123;</span><br><span class="line">      <span class="keyword">let</span> partitionIndex = inputLowIndex;</span><br><span class="line">      <span class="keyword">const</span> pivot = array[highIndex];</span><br><span class="line">      <span class="comment">// 把小于最右元素的元素与partitionIndex指向的元素交换位置</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> currentIndex = lowIndex; currentIndex &lt; highIndex; currentIndex += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[currentIndex] &lt; pivot) &#123;</span><br><span class="line">          swap(partitionIndex, currentIndex);</span><br><span class="line">          partitionIndex += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(partitionIndex, highIndex);</span><br><span class="line">      <span class="comment">// 以partitionIndex作为分界点，分开左右范围进行排序</span></span><br><span class="line">      sort(array, inputLowIndex, partitionIndex - <span class="number">1</span>);</span><br><span class="line">      sort(array, partitionIndex + <span class="number">1</span>, inputHighIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>3. 堆排序</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建最小堆</span></span><br><span class="line"><span class="comment">// 每次取出堆顶元素，然后把堆中最后的元素放到堆顶，根据规则，重新建立最小堆</span></span><br><span class="line">leftChildIndex(parentIndex) &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="number">2</span> * parentIndex) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">rightChildIndex(parentIndex) &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="number">2</span> * parentIndex) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">parentIndex(childIndex) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Math</span>.floor((childIndex - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最后一个元素开始确认父元素是否小于子元素</span></span><br><span class="line">heapifyUp() &#123;</span><br><span class="line">     <span class="keyword">let</span> currentIndex = heapContainer.length - <span class="number">1</span></span><br><span class="line">     <span class="keyword">while</span>(hasParent(currentIndex) &amp;&amp; heapContainer[parentIndex] &gt; heapContainer[currentIndex]) &#123;</span><br><span class="line">          swap(heapContainer, currentIndex, parentIndex);</span><br><span class="line">          currentIndex = parentIndex</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第一个元素开始确认父元素是否小于子元素</span></span><br><span class="line">heapifyDown() &#123;</span><br><span class="line">    <span class="keyword">let</span> currentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> nextIndex = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.hasLeftChild(currentIndex)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="keyword">this</span>.hasRightChild(currentIndex)</span><br><span class="line">        &amp;&amp; rightChild &gt; leftChild)</span><br><span class="line">      ) &#123;</span><br><span class="line">        nextIndex = getRightChildIndex(currentIndex);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextIndex = getLeftChildIndex(currentIndex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (heapContainer[currentIndex] &lt; heapContainer[nextIndex]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      swap(heapContainer, currentIndex, nextIndex);</span><br><span class="line">      currentIndex = nextIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(item) &#123;</span><br><span class="line">     heapContainer.push(item)</span><br><span class="line">     heapifyUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最小堆中取出堆顶，就是poll这个操作</span></span><br><span class="line">poll() &#123;</span><br><span class="line">     <span class="keyword">const</span> item = heapContainer[<span class="number">0</span>]</span><br><span class="line">     heapContainer[<span class="number">0</span>] = heapContainer.pop()</span><br><span class="line">     heapifyDown()</span><br><span class="line">     <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>奇怪的是根据下面代码来源的资料，heap sort的空间复杂度是O(1)，可是上面的实现方式是需要创建两个数组的，</em></strong><br><strong><em>按上面的实现应该是O(n)才对。后面经过搜索，得知heap sort实际上是可以原地实现的。实现如下：</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">add() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">    <span class="comment">// 从i到0构建**最大堆**</span></span><br><span class="line">    heapifyUp(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i++) &#123;</span><br><span class="line">    <span class="comment">// 让i与0交换</span></span><br><span class="line">    swap(i, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 调整堆至i - 1处，交换以后的i排除在heapifyDown的操作范围内</span></span><br><span class="line">    heapifyDown(i - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意上面的是最大堆，因为这样取出的时候可以把堆顶的这个最大值与末尾的元素进行交换</span></span><br><span class="line"><span class="comment">// 最后结果能够从小到大排列</span></span><br><span class="line"><span class="comment">// 上面写的都是伪代码，力求把逻辑简洁地表述出来</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/trekhleb/javascript-algorithms" target="_blank" rel="noopener">代码来源</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/11/04/web-front-end-knowledge-memo(Algorithm)-ep1/" data-id="ck2ouixw4000840u1dq3xqekn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/algorithm/">algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/interview/">interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/sorting/">sorting</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-web-front-end-knowledge-memo(Network)-ep1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/11/03/web-front-end-knowledge-memo(Network)-ep1/" class="article-date">
  <time datetime="2019-11-03T13:03:28.048Z" itemprop="datePublished">2019-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2019/11/03/web-front-end-knowledge-memo(Network)-ep1/">web前端知识学习笔记-网络篇(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="HTTP处于TCP-IP（互联网协议套件）的应用层，是一种无状态的协议。"><a href="#HTTP处于TCP-IP（互联网协议套件）的应用层，是一种无状态的协议。" class="headerlink" title="HTTP处于TCP/IP（互联网协议套件）的应用层，是一种无状态的协议。"></a>HTTP处于TCP/IP（互联网协议套件）的应用层，是一种无状态的协议。</h3><p><strong>（我的理解是无状态协议表示，每次请求应答都是独立的，不需要保证是否按顺序收发，不会维护client和server的状态，单次请求应答完成以后自动结束）</strong></p>
<h3 id="一次HTTP操作简化流程"><a href="#一次HTTP操作简化流程" class="headerlink" title="一次HTTP操作简化流程"></a>一次HTTP操作简化流程</h3><ol>
<li>发送HTTP请求（浏览器输入地址或XHR等方式）</li>
<li>通过DNS获取请求地址对应的IP地址</li>
<li>通过TCP/IP，与目标地址建立起TCP连接</li>
<li>TCP连接发送客户端的HTTP请求报文</li>
<li>客户端通过TCP连接发送HTTP应答报文</li>
<li>TCP连接关闭，如果HTTP请求报头中设置了<code>Connection:keep-alive</code>，则TCP会继续保持连接</li>
</ol>
<p><strong>值得注意的是keep-alive虽然是通过HTTP的报头设置的，但是实际执行的是在TCP中，所以不与HTTP是无状态的冲突</strong></p>
<p><strong>短连接</strong>是无<code>keep-alive</code>，请求完成以后，TCP自动关闭；<br><strong>长连接</strong>则相反。</p>
<p><strong>管线化（with pipelining）</strong>是指长连接中客户端无需等待上一次请求完成，再去做第二次请求，<strong>非管线化（without pipelining）</strong>则需要做这样的等待。<br><em>但实际上没有看过非管线化的情况（如果有，还请热心告诉我）</em></p>
<h3 id="格式示意图"><a href="#格式示意图" class="headerlink" title="格式示意图"></a>格式示意图</h3><p>请求报文：<br><img src="css/images/http-request-format.png" alt=""></p>
<p>响应报文：<br><img src="css/images/http-response-format.png" alt=""><br><a href="https://juejin.im/post/5ad4465d6fb9a028da7d0117" target="_blank" rel="noopener">图片来源</a></p>
<h3 id="常见的响应的状态码"><a href="#常见的响应的状态码" class="headerlink" title="常见的响应的状态码"></a>常见的响应的状态码</h3><p><strong>200</strong>(OK) <strong>客户端发过来的数据被正常处理</strong></p>
<p><strong>204</strong>(Not Content) <strong>正常响应，没有实体</strong></p>
<p><strong>206</strong>(Partial Content) <strong>范围请求，返回部分数据，响应报文中由Content-Range指定实体内容</strong></p>
<hr>
<p><strong>301</strong>(Moved Permanently) <strong>永久重定向</strong></p>
<p><strong>302</strong>(Found) <strong>临时重定向，重定向后的请求方法可作改变</strong></p>
<p><strong>303</strong>(See Other) <strong>重定向后的请求方法变为GET</strong></p>
<p><strong>304</strong>(Not Modified) <strong>状态未改变， 配合(If-Match、If-Modified-Since、If-None_Match、If-Range、If-Unmodified-Since)，与<em>HTTP缓存</em>相关</strong></p>
<p><strong>307</strong>(Temporary Redirect) <strong>临时重定向，不应改变其请求方法</strong></p>
<hr>
<p><strong>400</strong>(Bad Request) <strong>请求报文语法错误</strong></p>
<p><strong>401</strong>(unauthorized) <strong>需要认证</strong></p>
<p><strong>403</strong>(Forbidden) <strong>服务器拒绝访问对应的资源</strong></p>
<p><strong>404</strong>(Not Found) <strong>服务器上无法找到资源</strong></p>
<p><strong><em>401跟403不同的地方是，401可能是因为你没有登录，而403表示可能你没有相关的权限，有一次我通过npm发布包，错误提示403，我还错误地想是不是因为我没有登录呢，实际上是我的包名含有private scope，而我没有权限导致的</em></strong></p>
<hr>
<p><strong>500</strong>(Internal Server Error)<strong>服务器故障</strong></p>
<p><strong>503</strong>(Service Unavailable) <strong>服务器处于超负载或正在停机维护</strong></p>
<h4 id="从维基百科的配图中，虽然是说明UDP的，但也可以看出在TCP-IP层间传输中，大致存在这样的迭代关系"><a href="#从维基百科的配图中，虽然是说明UDP的，但也可以看出在TCP-IP层间传输中，大致存在这样的迭代关系" class="headerlink" title="从维基百科的配图中，虽然是说明UDP的，但也可以看出在TCP/IP层间传输中，大致存在这样的迭代关系"></a>从维基百科的配图中，虽然是说明UDP的，但也可以看出在TCP/IP层间传输中，大致存在这样的迭代关系</h4><p>(<strong>n</strong>表示层序)</p>
<p><img src="https://latex.codecogs.com/png.latex?packet_%7Bn%20-%201%7D%20%3D%20header_%7Bn%20-%201%7D%20&plus;%20packet_%7Bn%7D" alt=""></p>
<p><img src="css/images/UDP_encapsulation.png" alt=""></p>
<p><em>本文内容大部分基于<a href="">5分钟让你明白HTTP协议</a><a href="https://juejin.im/post/5ad4465d6fb9a028da7d0117" target="_blank" rel="noopener">https://juejin.im/post/5ad4465d6fb9a028da7d0117</a></em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/11/03/web-front-end-knowledge-memo(Network)-ep1/" data-id="ck2ouixwk000l40u1iqg5okd9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/HTTP/">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/interview/">interview</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-web-front-end-knowledge-memo(JS)-ep3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/11/02/web-front-end-knowledge-memo(JS)-ep3/" class="article-date">
  <time datetime="2019-11-02T13:41:15.157Z" itemprop="datePublished">2019-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2019/11/02/web-front-end-knowledge-memo(JS)-ep3/">web前端知识学习笔记-JS篇(3)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> inner;</span><br><span class="line">    inner = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> outter() <span class="comment">// 'function';</span></span><br></pre></td></tr></table></figure>
<p>变量提升和函数提升指的是JS预编译的一个操作。</p>
<p>首先对于<code>var</code>声明的变量，只存在全局作用域和函数作用域，不像<code>let</code>和<code>const</code>还有块作用域。</p>
<ol>
<li>变量提升（指<code>var</code>声明的变量）指的是作用域内出现的变量声明会把声明放到作用域的开头</li>
<li>函数提升是指除了1外的操作，还会把函数提前赋值给变量</li>
</ol>
<p>根据上面两个规则，上面的代码经预编译会变成如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inner;</span><br><span class="line">    inner = <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">    inner = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/11/02/web-front-end-knowledge-memo(JS)-ep3/" data-id="ck2ouixwj000k40u1l4kr3t0g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/hoisting/">hoisting</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/interview/">interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-web-front-end-knowledge-memo(JS)-ep2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/11/02/web-front-end-knowledge-memo(JS)-ep2/" class="article-date">
  <time datetime="2019-11-02T13:30:29.482Z" itemprop="datePublished">2019-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2019/11/02/web-front-end-knowledge-memo(JS)-ep2/">web前端知识学习笔记-JS篇(2)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="立即执行函数（immediatly-invoked-function-expression）"><a href="#立即执行函数（immediatly-invoked-function-expression）" class="headerlink" title="立即执行函数（immediatly invoked function expression）"></a>立即执行函数（immediatly invoked function expression）</h2><p>从题目总结其性质</p>
<ol>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">     a = <span class="number">10</span>;</span><br><span class="line">     b = <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">console</span>.log(a)</span><br><span class="line">     <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>总结：这里会输出a函数定义和20。</p>
<ol>
<li>性质一，IIFE的函数名，不会在括号外出现声明，所以不会与<code>const a</code>产生冲突错误。</li>
<li>IIFE的函数名可看作是<code>const</code>，对其再赋值会无效，在严格模式下会报错。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/11/02/web-front-end-knowledge-memo(JS)-ep2/" data-id="ck2ouixwf000h40u1na8q6t3w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/IIFE/">IIFE</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/interview/">interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/立即执行函数/">立即执行函数</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-web-front-end-knowledge-memo(JS)-ep1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/11/02/web-front-end-knowledge-memo(JS)-ep1/" class="article-date">
  <time datetime="2019-11-02T13:18:18.384Z" itemprop="datePublished">2019-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2019/11/02/web-front-end-knowledge-memo(JS)-ep1/">web前端知识学习笔记-JS篇(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一条关于setTimeout和promise的执行顺序的题目。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">     <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">          resolve();</span><br><span class="line">     &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'5'</span>);</span><br><span class="line">     resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'6'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">     <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'8'</span>);</span><br><span class="line">          resolve();</span><br><span class="line">     &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'9'</span>)</span><br><span class="line">     &#125;)</span><br><span class="line">&#125;, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>在浏览器中，其正确顺序是1,5,6,2,3,4,7,8,9<br>相关知识可以参照<a href="https://medium.com/@Rahulx1/understanding-event-loop-call-stack-event-job-queue-in-javascript-63dcd2c71ecd" target="_blank" rel="noopener">Understanding Event Loop, Call Stack, Event &amp; Job Queue in Javascript</a></p>
<p>简单总结就是</p>
<ol>
<li>先执行所有的同步代码，异步代码会放到eventloop执行, setTimeout会放到callback queue, promise会放到job queue</li>
<li>进入事件循环</li>
<li>执行job queue的代码，当promise是一个立刻resolve的promise，then产生的promise会在此时放到job queue，由于job queue中有这一步放置的task，所以会继续执行job queue，而不是跳到callback queue中</li>
<li>再执行callback queue的代码</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/11/02/web-front-end-knowledge-memo(JS)-ep1/" data-id="ck2ouixwh000j40u1xp1gn29r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/eventloop/">eventloop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/interview/">interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/promise/">promise</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/setTimeout/">setTimeout</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-web-front-end-knowledge-memo(HTML)-ep2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/11/02/web-front-end-knowledge-memo(HTML)-ep2/" class="article-date">
  <time datetime="2019-11-02T12:47:53.354Z" itemprop="datePublished">2019-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2019/11/02/web-front-end-knowledge-memo(HTML)-ep2/">web前端知识学习笔记-HTML篇(2)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>移动端的适配离不开meta标签的viewport设置，比较常见的设置<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>属性：</p>
<ol>
<li>width表示将document内容宽度设为width制定的数值，可填具体数值，如640，或device-width（表示device indepent pixel,简称DIP）</li>
<li>intial-scale, minimum-scale, maximum-scale，表示将可视窗口或者简单理解window.innerWidth，设为<code>DIP / scale</code>，例如当width设为640，而intial-scale设为2.0，那么<code>window.innerWidth === 320</code>，那么窗口内只能看到所有内容的一半。</li>
<li><p>关于刘海屏的适配，最开始由ios提出增加一个叫做viewport-fit的属性，一般可用contain 和 cover两个值，<br>具体效果可以看下面的示意图:</p>
<ol>
<li><strong>contain</strong></li>
</ol>
<p><img src="css/images/viewport-fit-contain.png" alt="contain"></p>
<ol start="2">
<li><strong>cover</strong></li>
</ol>
<p><img src="css/images/viewport-fit-contain.png" alt="cover"></p>
<p><a href="https://medium.com/@bobtung/%E9%9D%A2%E5%B0%8Diphone-x-web%E8%A8%AD%E8%A8%88%E5%B8%AB%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%B9%BE%E5%80%8Bcss%E5%B1%AC%E6%80%A7-b7c03b314c6a" target="_blank" rel="noopener">图片来源</a></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/11/02/web-front-end-knowledge-memo(HTML)-ep2/" data-id="ck2ouixwc000f40u13nda93n4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/HTML/">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/interview/">interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/meta/">meta</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/viewport/">viewport</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-web-front-end-knowledge-memo(HTML)-ep1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/11/02/web-front-end-knowledge-memo(HTML)-ep1/" class="article-date">
  <time datetime="2019-11-02T12:27:25.214Z" itemprop="datePublished">2019-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study-memo/2019/11/02/web-front-end-knowledge-memo(HTML)-ep1/">web前端知识学习笔记-HTML篇(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="语义化，英文为semantics。"><a href="#语义化，英文为semantics。" class="headerlink" title="语义化，英文为semantics。"></a>语义化，英文为semantics。</h3><h3 id="根据MDN上的介绍，语义化的优点有"><a href="#根据MDN上的介绍，语义化的优点有" class="headerlink" title="根据MDN上的介绍，语义化的优点有"></a>根据MDN上的介绍，语义化的优点有</h3><ol>
<li>在SEO中会有较高权重</li>
<li>方便视觉障碍人士阅读页面</li>
<li>方便查找有特定意义的标签</li>
<li>提示开发者生成的数据类型</li>
<li>语义化仿照与自定义组件的命名</li>
</ol>
<h3 id="常见的新语义化标签"><a href="#常见的新语义化标签" class="headerlink" title="常见的新语义化标签"></a>常见的新语义化标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span> <span class="comment">&lt;!--与summary一起使用，点击details显示summary的内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">summary</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figcaption</span>&gt;</span> <span class="comment">&lt;!--图片说明--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mark</span>&gt;</span> <span class="comment">&lt;!--高亮，默认为黄色背景--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span> <span class="comment">&lt;!--导航--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">time</span>&gt;</span> <span class="comment">&lt;!--时间--&gt;</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/11/02/web-front-end-knowledge-memo(HTML)-ep1/" data-id="ck2ouixwa000c40u1bybd18uj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/HTML/">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/interview/">interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/语义化/">语义化</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/study-memo/page/2/">2</a><a class="extend next" rel="next" href="/study-memo/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/AST/">AST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/CLI/">CLI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/Clang/">Clang++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/IIFE/">IIFE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/Needleman-Wunsch/">Needleman-Wunsch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/algorithm/">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/diff/">diff</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/dll/">dll</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/eventloop/">eventloop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/externals/">externals</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/hoisting/">hoisting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/hot-reload/">hot-reload</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/interview/">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/meta/">meta</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/parser/">parser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/performance/">performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/plugin/">plugin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/promise/">promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/querySelector/">querySelector</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/redux/">redux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/setTimeout/">setTimeout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/sorting/">sorting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/stack/">stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/store/">store</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/stream/">stream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/template/">template</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/temporary-variable/">temporary variable</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/viewport/">viewport</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/watcher/">watcher</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/websocket/">websocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/whistle/">whistle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/windows/">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/立即执行函数/">立即执行函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/语义化/">语义化</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/study-memo/tags/AST/" style="font-size: 10px;">AST</a> <a href="/study-memo/tags/C/" style="font-size: 10px;">C++</a> <a href="/study-memo/tags/CLI/" style="font-size: 10px;">CLI</a> <a href="/study-memo/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/study-memo/tags/Clang/" style="font-size: 10px;">Clang++</a> <a href="/study-memo/tags/HTML/" style="font-size: 15px;">HTML</a> <a href="/study-memo/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/study-memo/tags/IIFE/" style="font-size: 10px;">IIFE</a> <a href="/study-memo/tags/Needleman-Wunsch/" style="font-size: 10px;">Needleman-Wunsch</a> <a href="/study-memo/tags/algorithm/" style="font-size: 17.5px;">algorithm</a> <a href="/study-memo/tags/diff/" style="font-size: 10px;">diff</a> <a href="/study-memo/tags/dll/" style="font-size: 10px;">dll</a> <a href="/study-memo/tags/eventloop/" style="font-size: 10px;">eventloop</a> <a href="/study-memo/tags/externals/" style="font-size: 10px;">externals</a> <a href="/study-memo/tags/git/" style="font-size: 10px;">git</a> <a href="/study-memo/tags/hoisting/" style="font-size: 10px;">hoisting</a> <a href="/study-memo/tags/hot-reload/" style="font-size: 10px;">hot-reload</a> <a href="/study-memo/tags/interview/" style="font-size: 20px;">interview</a> <a href="/study-memo/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/study-memo/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/study-memo/tags/meta/" style="font-size: 10px;">meta</a> <a href="/study-memo/tags/parser/" style="font-size: 10px;">parser</a> <a href="/study-memo/tags/performance/" style="font-size: 10px;">performance</a> <a href="/study-memo/tags/plugin/" style="font-size: 10px;">plugin</a> <a href="/study-memo/tags/promise/" style="font-size: 10px;">promise</a> <a href="/study-memo/tags/querySelector/" style="font-size: 10px;">querySelector</a> <a href="/study-memo/tags/react/" style="font-size: 10px;">react</a> <a href="/study-memo/tags/redux/" style="font-size: 10px;">redux</a> <a href="/study-memo/tags/setTimeout/" style="font-size: 10px;">setTimeout</a> <a href="/study-memo/tags/sorting/" style="font-size: 10px;">sorting</a> <a href="/study-memo/tags/stack/" style="font-size: 10px;">stack</a> <a href="/study-memo/tags/store/" style="font-size: 10px;">store</a> <a href="/study-memo/tags/stream/" style="font-size: 10px;">stream</a> <a href="/study-memo/tags/template/" style="font-size: 10px;">template</a> <a href="/study-memo/tags/temporary-variable/" style="font-size: 10px;">temporary variable</a> <a href="/study-memo/tags/viewport/" style="font-size: 10px;">viewport</a> <a href="/study-memo/tags/vue/" style="font-size: 12.5px;">vue</a> <a href="/study-memo/tags/watcher/" style="font-size: 10px;">watcher</a> <a href="/study-memo/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/study-memo/tags/websocket/" style="font-size: 10px;">websocket</a> <a href="/study-memo/tags/whistle/" style="font-size: 10px;">whistle</a> <a href="/study-memo/tags/windows/" style="font-size: 10px;">windows</a> <a href="/study-memo/tags/立即执行函数/" style="font-size: 10px;">立即执行函数</a> <a href="/study-memo/tags/语义化/" style="font-size: 10px;">语义化</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/study-memo/2019/12/27/from-whistle-hot-reload-plugin-develoment-to-websocket-mechanism/">从whistle热重载插件到websocket工作原理</a>
          </li>
        
          <li>
            <a href="/study-memo/2019/11/13/HTML-parser-and-querySelector/">HTML parser和querySelector实现分析</a>
          </li>
        
          <li>
            <a href="/study-memo/2019/11/10/Leetcode-84-Largest-Rectangle-in-Histogram/">Leetcode 84 Largest Rectangle in Histogram分析</a>
          </li>
        
          <li>
            <a href="/study-memo/2019/11/04/web-front-end-knowledge-memo(Algorithm)-ep1/">web前端知识学习笔记-算法篇(1)</a>
          </li>
        
          <li>
            <a href="/study-memo/2019/11/03/web-front-end-knowledge-memo(Network)-ep1/">web前端知识学习笔记-网络篇(1)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Sociosarbis<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/study-memo/" class="mobile-nav-link">Home</a>
  
    <a href="/study-memo/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/study-memo/fancybox/jquery.fancybox.css">
  <script src="/study-memo/fancybox/jquery.fancybox.pack.js"></script>


<script src="/study-memo/js/script.js"></script>



  </div>
</body>
</html>
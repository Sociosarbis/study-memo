<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>从whistle热重载插件到websocket工作原理 | a house in the woods</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言 工作上有些需求是需要去改后端渲染的文件的，但是由于不是通过webpack开发，没有修改完立刻更新页面的功能，所以显得不是太方便。要实时更新页面可以通过热重载或热更新，热重载比较简单，其实就是页面自动reload，热更新则需要重新打包已更改的文件，然后通过websoket发送新的补丁，完成更改。   需要实现的功能 先不谈复杂的热更新，对于后端渲染的这类比较简单的页面，热重载已经能够很好地方便">
<meta name="keywords" content="whistle,hot-reload,plugin,websocket,stream">
<meta property="og:type" content="article">
<meta property="og:title" content="从whistle热重载插件到websocket工作原理">
<meta property="og:url" content="https://sociosarbis.github.io/study-memo/2019/12/27/from-whistle-hot-reload-plugin-develoment-to-websocket-mechanism/index.html">
<meta property="og:site_name" content="a house in the woods">
<meta property="og:description" content="前言 工作上有些需求是需要去改后端渲染的文件的，但是由于不是通过webpack开发，没有修改完立刻更新页面的功能，所以显得不是太方便。要实时更新页面可以通过热重载或热更新，热重载比较简单，其实就是页面自动reload，热更新则需要重新打包已更改的文件，然后通过websoket发送新的补丁，完成更改。   需要实现的功能 先不谈复杂的热更新，对于后端渲染的这类比较简单的页面，热重载已经能够很好地方便">
<meta property="og:locale" content="zh">
<meta property="og:updated_time" content="2019-12-26T16:53:45.185Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从whistle热重载插件到websocket工作原理">
<meta name="twitter:description" content="前言 工作上有些需求是需要去改后端渲染的文件的，但是由于不是通过webpack开发，没有修改完立刻更新页面的功能，所以显得不是太方便。要实时更新页面可以通过热重载或热更新，热重载比较简单，其实就是页面自动reload，热更新则需要重新打包已更改的文件，然后通过websoket发送新的补丁，完成更改。   需要实现的功能 先不谈复杂的热更新，对于后端渲染的这类比较简单的页面，热重载已经能够很好地方便">
  
    <link rel="alternate" href="/study-memo/atom.xml" title="a house in the woods" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/study-memo/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/study-memo/" id="logo">a house in the woods</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/study-memo/">Home</a>
        
          <a class="main-nav-link" href="/study-memo/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/study-memo/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://sociosarbis.github.io/study-memo"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-from-whistle-hot-reload-plugin-develoment-to-websocket-mechanism" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study-memo/2019/12/27/from-whistle-hot-reload-plugin-develoment-to-websocket-mechanism/" class="article-date">
  <time datetime="2019-12-26T16:36:40.565Z" itemprop="datePublished">2019-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      从whistle热重载插件到websocket工作原理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>工作上有些需求是需要去改后端渲染的文件的，但是由于不是通过webpack开发，没有修改完立刻更新页面的功能，所以显得不是太方便。要实时更新页面可以通过热重载或热更新，热重载比较简单，其实就是页面自动reload，热更新则需要重新打包已更改的文件，然后通过websoket发送新的补丁，完成更改。 </li>
</ul>
<h3 id="需要实现的功能"><a href="#需要实现的功能" class="headerlink" title="需要实现的功能"></a>需要实现的功能</h3><ul>
<li>先不谈复杂的热更新，对于后端渲染的这类比较简单的页面，热重载已经能够很好地方便我们的开发了。</li>
<li>要做热重载，需要做以下两个功能：<ol>
<li>监听文件的更改</li>
<li>通知页面进行reload</li>
</ol>
</li>
<li>第一点比较简单，可以使用<a href=""><code>fs.watch</code></a>或者跨平台的库<a href="https://www.npmjs.com/package/chokidar" target="_blank" rel="noopener"><code>chokidar</code></a>，都可以进行对文件更改的监听。</li>
<li>第二点对页面进行通知，我们平时用webpack开发的时候自然会发现页面会打开一个websocket的连接，而这个连接就是起服务器与页面客户端间通信的作用。</li>
</ul>
<h3 id="websocket的工作流程"><a href="#websocket的工作流程" class="headerlink" title="websocket的工作流程"></a>websocket的工作流程</h3><ul>
<li>下一步就是怎么创建一个websokcet的连接的问题，分为两个部分，server和client</li>
<li>client：<ul>
<li>对于比较简单的应用，例如这种通知更新的，可以简单地使用浏览器提供的<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank" rel="noopener"><code>Websocket</code></a>的api</li>
</ul>
</li>
<li><p>sever：</p>
<ul>
<li>首先node没有提供直接的api，可以用第三方库或者自己实现。对于第三方库，比较著名的有<code>socket.io</code>，不过需要在页面中使用客户端对应的库，所以不作考虑。而留意到webpack-dev-server用到的库是<code>sockjs-node</code>， 使用浏览器的api就可完成连接，所以这里就选用该库。</li>
<li><p>先来看一下简单用例①:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> sockjs = <span class="built_in">require</span>(<span class="string">'sockjs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> echo = sockjs.createServer(&#123; <span class="attr">prefix</span>:<span class="string">'/echo'</span> &#125;);</span><br><span class="line">echo.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">conn</span>) </span>&#123;</span><br><span class="line">conn.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    conn.write(message);</span><br><span class="line">&#125;);</span><br><span class="line">conn.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line">echo.attach(server);</span><br><span class="line">server.listen(<span class="number">9999</span>, <span class="string">'0.0.0.0'</span>);</span><br></pre></td></tr></table></figure>
<p>如果了解过node.js，<code>http.createServer</code>的作用是创建一个http的服务器，那为什么又有一个类似的<code>sockjs.createServer</code>的方法，难道真的是创建多一个服务器吗？<br>带着这个疑问，翻看源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">events</span>.<span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(user_options) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.options = <span class="built_in">Object</span>.assign(</span><br><span class="line">        &#123;</span><br><span class="line">            prefix: <span class="string">''</span>,</span><br><span class="line">            transports: [</span><br><span class="line">            <span class="string">'eventsource'</span>,</span><br><span class="line">            <span class="string">'htmlfile'</span>,</span><br><span class="line">            <span class="string">'jsonp-polling'</span>,</span><br><span class="line">            <span class="string">'websocket'</span>,</span><br><span class="line">            <span class="string">'websocket-raw'</span>,</span><br><span class="line">            <span class="string">'xhr-polling'</span>,</span><br><span class="line">            <span class="string">'xhr-streaming'</span></span><br><span class="line">            ],</span><br><span class="line">            response_limit: <span class="number">128</span> * <span class="number">1024</span>,</span><br><span class="line">            faye_server_options: <span class="literal">null</span>,</span><br><span class="line">            jsessionid: <span class="literal">false</span>,</span><br><span class="line">            heartbeat_delay: <span class="number">25000</span>,</span><br><span class="line">            disconnect_delay: <span class="number">5000</span>,</span><br><span class="line">            log() &#123;&#125;,</span><br><span class="line">            sockjs_url: <span class="string">'https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        user_options</span><br><span class="line">        );</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>.handler = webjs.generateHandler(<span class="keyword">this</span>, listener.generateDispatcher(<span class="keyword">this</span>.options));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它并没有做任何与连接相关的工作。然后再看到用例①中对于sockjs创建的这个<strong>“server”</strong> ，还有一步是<code>echo.attach(server)</code>，看来这里才是<strong>“sockjs sever”</strong>工作的入口。源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">attach(server) &#123;</span><br><span class="line">    <span class="keyword">this</span>._rlisteners = <span class="keyword">this</span>._installListener(server, <span class="string">'request'</span>);</span><br><span class="line">    <span class="keyword">this</span>._ulisteners = <span class="keyword">this</span>._installListener(server, <span class="string">'upgrade'</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>原来是对<strong>http server</strong>的<strong>request</strong>和<strong>upgrade</strong>事件做监听。<br><strong>request</strong>是收到http请求时触发的，那<strong>upgrade</strong>呢？</p>
<h4 id="根据node的文档所述："><a href="#根据node的文档所述：" class="headerlink" title="根据node的文档所述："></a>根据node的文档所述：</h4><blockquote>
<p>Emitted each time a server responds to a <strong>request with an upgrade</strong>. </p>
</blockquote>
<p>这里的<strong>request with an upgrade</strong>，通过后面的example，粗浅地可以认为是<strong>Connection</strong> header为<code>&#39;Upgrade&#39;</code>，并且还有一个<code>Upgrade</code>header的<strong>request</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    ...</span><br><span class="line">    headers: &#123;</span><br><span class="line">    <span class="string">'Connection'</span>: <span class="string">'Upgrade'</span>,</span><br><span class="line">    <span class="string">'Upgrade'</span>: <span class="string">'websocket'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> req = http.request(options);</span><br></pre></td></tr></table></figure>
</li>
<li><p>request事件的callback参数为<strong>request和response</strong>，而upgrade事件则是<strong>request，socket和head</strong>。第二个参数由<strong>response变为socket</strong>，而这个socket参数就是client和server间的TCP连接，而<strong>websocket</strong>就是对这个<strong>TCP连接的socket对象</strong>进行操作，根据<strong>websocket</strong>协议的规则，对<strong>socket</strong>对象中通信的数据进行解析读入和封装用户的消息进行写入。</p>
</li>
<li><p>顺带一提，对于要upgrade为websocket的请求，服务端也会写入符合http规则的响应报文（而这个过程称作建立websocket连接的握手），并且不会调用<code>response.end或者说socket.end</code>去结束服务端和客户端的连接。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.write(<span class="string">'HTTP/1.1 101 Web Socket Protocol Handshake\r\n'</span> +</span><br><span class="line">    <span class="string">'Upgrade: WebSocket\r\n'</span> +</span><br><span class="line">    <span class="string">'Connection: Upgrade\r\n'</span> +</span><br><span class="line">    <span class="string">'\r\n'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>ps：</strong>建立websocket的request还会有<code>sec-websocket-version</code>和<code>sec-websocket-key</code>等headers，而response还会有<code>sec-webSocket-accept</code>等headers，由于本文主旨在于建立websocket的通信流程的概念，所以具体的协议标准等知识，可自行search。</p>
</li>
<li><p>建立了websocket的连接，下面就是要知道是怎么从socket收到消息和写消息到socket中。这两个步骤对应于这两行来自<strong>faye-websocket\lib\faye\websocket\api.js</strong>的代码(<strong>faye-websocket</strong>是<strong>sockjs-node</strong>的依赖库)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._stream.pipe(<span class="keyword">this</span>._driver.io);</span><br><span class="line"><span class="keyword">this</span>._driver.io.pipe(<span class="keyword">this</span>._stream);</span><br></pre></td></tr></table></figure>
<p><code>this._stream</code>就是TCP的<code>socket</code>（也是流对象），而<code>this._driver.io</code>是一个双工(Duplex, 意为可读可写)的流。<br><strong>ps:</strong>流就是nodejs的Stream类。</p>
</li>
<li>之前我看到pipe这个方法，对他的机制有点摸不着头脑，不知道他是在什么时候才会把数据传到<strong>可写流（Stream.Writable）</strong>中。要解决这个疑问，只需要看到这一步，就知道触发<strong>可读流(Stream.Readable)</strong>的<code>data</code>事件时，就会把数据写到可写流中。而data事件的其中一个触发时机，就在Readable的read方法中。而pipe方法在最后，会通过resume方法，让流进入<strong>flowing</strong> mode，这个mode简单来讲就是假如Readable的<strong>Internal buffer(内部缓存)</strong>，就会通过循环不断地调用read。<h5 id="最后一个疑问他内部缓存地数据又是从哪里来的呢？"><a href="#最后一个疑问他内部缓存地数据又是从哪里来的呢？" class="headerlink" title="最后一个疑问他内部缓存地数据又是从哪里来的呢？"></a>最后一个疑问他内部缓存地数据又是从哪里来的呢？</h5>答案是在<code>read</code>方法中，会调用<code>_read</code>方法。<code>_read</code>方法的作用是调用<code>Readable.push</code>方法，把数据放到<strong>Internal buffer</strong>里。可能这也是为什么在继承或者实现Readable的时候，需要去实现一个<code>_read</code>方法来获取自定义数据。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/nodejs/node/blob/master/lib/_stream_readable.js</span></span><br><span class="line">src.on(<span class="string">'data'</span>, ondata);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> ret = dest.write(chunk);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!state.flowing) &#123;</span><br><span class="line">    debug(<span class="string">'pipe resume'</span>);</span><br><span class="line">    src.resume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dest;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="websocket的内容就介绍到这里，下面是要讲的是完成热重载需求的whistle插件的开发。"><a href="#websocket的内容就介绍到这里，下面是要讲的是完成热重载需求的whistle插件的开发。" class="headerlink" title="websocket的内容就介绍到这里，下面是要讲的是完成热重载需求的whistle插件的开发。"></a>websocket的内容就介绍到这里，下面是要讲的是完成热重载需求的whistle插件的开发。</h4><p>为了更好地理解下面的内容，可先阅读whistle文档中<a href="https://wproxy.org/whistle/plugins.html" target="_blank" rel="noopener"><strong>插件开发</strong></a>的部分。</p>
<p>如下是我在看过文档，github上的demo和whistle的源码后的几点所得。</p>
<ol>
<li>whistle的插件实际上就是让插件export一个接收<strong>server对象的函数</strong>, 然后自己编写对<strong>server对象</strong>事件响应的callback，事件主要是request和connect，request就是普通的http请求，connect可以是websocket或者tunnel请求(<em>ps:没了解过tunnel请求</em>)</li>
<li><p><strong>每个插件都会创建一个监听本地新端口的入口server，其主要的作用是把请求分发给它其下的子server，而这些server虽然都是真的http server，但它们不会监听端口，在请求的不同阶段，入口server会把请求分发到对应的子server</strong>，子server有如下这些：</p>
<ol>
<li>uiServer</li>
<li>reqRead</li>
<li>reqWrite</li>
<li>resRead</li>
<li>resRulesServer</li>
<li>resStatsServer</li>
<li>resWrite</li>
<li>rulesServer</li>
<li>server</li>
<li>statsServer</li>
<li>tunnelReqRead</li>
<li>tunnelReqWrite</li>
<li>tunnelResRead</li>
<li>tunnelResWrite</li>
<li>tunnelRulesServer</li>
<li>wsReqRead</li>
<li>wsReqWrite</li>
<li>wsResRead</li>
<li><p>wsResWrite<br>但问题是具体需要怎么响应对这些server的请求事件，文档里没有说明。只能在提供的demo中找到，某些server具体需要response什么东西。<br>例如<code>&#39;rulesServer&#39;</code>结尾的server，需要response如下的JSON数据来动态地去添加whistle的规则。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    rules: <span class="string">`<span class="subst">$&#123;req.headers.host&#125;</span>/sw-register.js file://&#123;sw-register&#125;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;req.headers.host&#125;</span>/sw.js file://&#123;sw-content&#125;`</span>,</span><br><span class="line">    values: &#123;</span><br><span class="line">        <span class="string">'sw-register'</span>: registerContent,</span><br><span class="line">        <span class="string">'sw-content'</span>: content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">null</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p><strong>rules</strong>是whisle规则的文本，<strong>values</strong>则是用于替换规则中的变量。<br>所以如果我们需要给我页面注入，websocket client的代码的话就在ruleServer中<code>response.end(rules)</code>就可以实现了。</p>
</li>
</ol>
</li>
<li>规则的值，如<code>www.ifeng.com method://post</code>中的<code>post</code>，可通过<code>req.originalReq.ruleValue</code>获取。</li>
<li>server当中有两个比较特别的，一个是<strong>uiServer</strong>，需要写一个完整的有前端页面的web应用，让用户修改插件的配置，给其他server去获取使用。另外一个是上面<strong>No.9的”server”</strong>，这个相当于一个代理的服务器，他的response会成为最后whistle传回来的那个response，其他的如ruleServer，就只是像上面说的只是通过resposne来增加一些临时的新规则。</li>
<li>*Read,*Write这两种结尾的server，本人到目前为止还不清楚到底要怎么用。</li>
</ol>
<h3 id="下面是这个插件简单的实现代码："><a href="#下面是这个插件简单的实现代码：" class="headerlink" title="下面是这个插件简单的实现代码："></a>下面是这个插件简单的实现代码：</h3><p><a href="https://github.com/Sociosarbis/whistle.hot-reload-plugin" target="_blank" rel="noopener">whistle.hot-reload-plugin</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>虽然这个功能很简单，但是它涉及到的知识还是很多的，而且还没有完全弄明白， 后面继续学习。</li>
<li>whistle的代码目前对我来说还是比较复杂的，涉及到协议的不同规则，请求转发， stream pipe等web后端的知识。 </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sociosarbis.github.io/study-memo/2019/12/27/from-whistle-hot-reload-plugin-develoment-to-websocket-mechanism/" data-id="ck64y70xy003fjgu1zri58cwj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/hot-reload/">hot-reload</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/plugin/">plugin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/stream/">stream</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/websocket/">websocket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/study-memo/tags/whistle/">whistle</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/study-memo/2020/01/01/2D-bin-packing-algorithm/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          一种2D装箱算法
        
      </div>
    </a>
  
  
    <a href="/study-memo/2019/11/13/HTML-parser-and-querySelector/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">HTML parser和querySelector实现分析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/AST/">AST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/CLI/">CLI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/Clang/">Clang++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/IIFE/">IIFE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/Needleman-Wunsch/">Needleman-Wunsch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/SSR/">SSR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/Yox/">Yox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/algorithm/">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/bin-pack/">bin-pack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/compile/">compile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/diff/">diff</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/dll/">dll</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/eventloop/">eventloop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/expression/">expression</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/externals/">externals</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/framework/">framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/hoisting/">hoisting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/hot-reload/">hot-reload</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/interview/">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/meta/">meta</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/mvvm/">mvvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/parser/">parser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/performance/">performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/plugin/">plugin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/promise/">promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/querySelector/">querySelector</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/redux/">redux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/setTimeout/">setTimeout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/sorting/">sorting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/sprite/">sprite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/stack/">stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/store/">store</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/stream/">stream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/template/">template</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/temporary-variable/">temporary variable</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/viewport/">viewport</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/watcher/">watcher</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/websocket/">websocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/whistle/">whistle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/windows/">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/立即执行函数/">立即执行函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/study-memo/tags/语义化/">语义化</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/study-memo/tags/AST/" style="font-size: 10px;">AST</a> <a href="/study-memo/tags/C/" style="font-size: 10px;">C++</a> <a href="/study-memo/tags/CLI/" style="font-size: 10px;">CLI</a> <a href="/study-memo/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/study-memo/tags/Clang/" style="font-size: 10px;">Clang++</a> <a href="/study-memo/tags/HTML/" style="font-size: 15px;">HTML</a> <a href="/study-memo/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/study-memo/tags/IIFE/" style="font-size: 10px;">IIFE</a> <a href="/study-memo/tags/Needleman-Wunsch/" style="font-size: 10px;">Needleman-Wunsch</a> <a href="/study-memo/tags/SSR/" style="font-size: 10px;">SSR</a> <a href="/study-memo/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/study-memo/tags/Yox/" style="font-size: 10px;">Yox</a> <a href="/study-memo/tags/algorithm/" style="font-size: 17.5px;">algorithm</a> <a href="/study-memo/tags/bin-pack/" style="font-size: 10px;">bin-pack</a> <a href="/study-memo/tags/compile/" style="font-size: 10px;">compile</a> <a href="/study-memo/tags/diff/" style="font-size: 10px;">diff</a> <a href="/study-memo/tags/dll/" style="font-size: 10px;">dll</a> <a href="/study-memo/tags/eventloop/" style="font-size: 10px;">eventloop</a> <a href="/study-memo/tags/expression/" style="font-size: 10px;">expression</a> <a href="/study-memo/tags/externals/" style="font-size: 10px;">externals</a> <a href="/study-memo/tags/framework/" style="font-size: 10px;">framework</a> <a href="/study-memo/tags/git/" style="font-size: 10px;">git</a> <a href="/study-memo/tags/hoisting/" style="font-size: 10px;">hoisting</a> <a href="/study-memo/tags/hot-reload/" style="font-size: 10px;">hot-reload</a> <a href="/study-memo/tags/interview/" style="font-size: 20px;">interview</a> <a href="/study-memo/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/study-memo/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/study-memo/tags/meta/" style="font-size: 10px;">meta</a> <a href="/study-memo/tags/mvvm/" style="font-size: 10px;">mvvm</a> <a href="/study-memo/tags/parser/" style="font-size: 10px;">parser</a> <a href="/study-memo/tags/performance/" style="font-size: 12.5px;">performance</a> <a href="/study-memo/tags/plugin/" style="font-size: 10px;">plugin</a> <a href="/study-memo/tags/promise/" style="font-size: 10px;">promise</a> <a href="/study-memo/tags/querySelector/" style="font-size: 10px;">querySelector</a> <a href="/study-memo/tags/react/" style="font-size: 10px;">react</a> <a href="/study-memo/tags/redux/" style="font-size: 10px;">redux</a> <a href="/study-memo/tags/setTimeout/" style="font-size: 10px;">setTimeout</a> <a href="/study-memo/tags/sorting/" style="font-size: 10px;">sorting</a> <a href="/study-memo/tags/sprite/" style="font-size: 10px;">sprite</a> <a href="/study-memo/tags/stack/" style="font-size: 10px;">stack</a> <a href="/study-memo/tags/store/" style="font-size: 10px;">store</a> <a href="/study-memo/tags/stream/" style="font-size: 10px;">stream</a> <a href="/study-memo/tags/template/" style="font-size: 12.5px;">template</a> <a href="/study-memo/tags/temporary-variable/" style="font-size: 10px;">temporary variable</a> <a href="/study-memo/tags/viewport/" style="font-size: 10px;">viewport</a> <a href="/study-memo/tags/vue/" style="font-size: 17.5px;">vue</a> <a href="/study-memo/tags/watcher/" style="font-size: 10px;">watcher</a> <a href="/study-memo/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/study-memo/tags/websocket/" style="font-size: 10px;">websocket</a> <a href="/study-memo/tags/whistle/" style="font-size: 10px;">whistle</a> <a href="/study-memo/tags/windows/" style="font-size: 10px;">windows</a> <a href="/study-memo/tags/立即执行函数/" style="font-size: 10px;">立即执行函数</a> <a href="/study-memo/tags/语义化/" style="font-size: 10px;">语义化</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/study-memo/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/study-memo/2020/04/19/optimization-techniques-for-better-performance-of-vue-app/">提高Vue应用性能的技巧</a>
          </li>
        
          <li>
            <a href="/study-memo/2020/02/23/yox-research-template-expression-episode/">Yox框架研究（1）—模板表达式编译篇</a>
          </li>
        
          <li>
            <a href="/study-memo/2020/02/01/vue-ssr-demo-following-official-guide/">按照官方指南实践vue SSR</a>
          </li>
        
          <li>
            <a href="/study-memo/2020/01/01/2D-bin-packing-algorithm/">一种2D装箱算法</a>
          </li>
        
          <li>
            <a href="/study-memo/2019/12/27/from-whistle-hot-reload-plugin-develoment-to-websocket-mechanism/">从whistle热重载插件到websocket工作原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Sociosarbis<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/study-memo/" class="mobile-nav-link">Home</a>
  
    <a href="/study-memo/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/study-memo/fancybox/jquery.fancybox.css">
  <script src="/study-memo/fancybox/jquery.fancybox.pack.js"></script>


<script src="/study-memo/js/script.js"></script>



  </div>
</body>
</html>